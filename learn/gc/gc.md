## 垃圾回收机制
引用计数器：每个对象都为何一个引用计数，被引用时+1，无需引用时-1，直到0时销毁 （可以很快回收无需等到垃圾回收触发时但是需要实时维护） ———— swift
标记清除：从根遍历所有引用对象，如果没有被标记的视为清除 （无需实时维护但是需要STW时间导致整个不可用）———— go
分代收集：按照对象的生命周期时长划分不同的代空间，不同代有不同的回收算法和回收频率(性能好可以对不同的代进行配置) ———— java


###  STW
1.暂停所有业务逻辑   2.开始标记找出能可达/不可达对象   3.标记完成清除不可达对象

### 三色标记法   
#### 1）黑色，已经扫描过的对象；2）灰色，就是待扫描对象；3）白色，没有扫描的对象

1.所有对象刚开始都是白色，标识没有遍历过的数据
2.GC开始时扫描root根节点为灰色，如果发现子对象指针有值标记为黑色，子节点对象为则标记为灰色 （黑色代表一定不用被删除因为有子节点，灰色对象标识处于活跃状态不用被删除）
3.遍历全部后剩下的白色节点即是没有已经没被引用，则可以被清除

满足强弱之一，即可保证对象不丢失
    强三色不变式 ： 强制不允许黑色对象引用白色对象
    弱三色不变式：黑色可以引用白色对象，但需要白色对象存在其他的灰色对象对他引用

go 1.5 版本标识时需要暂停所有的业务，等到所以标记完才才可执行业务，此时异步现场继续清理
    为了解决这个问题引出了插入写屏障及删除写屏障。写屏障即垃圾回收的一个机制。以便在写操作时告诉垃圾回收有新的指针别修改或创建。


插入写屏障
    A对象引用B对象，B对象被标记灰色，如果没有写屏障此时B依旧是白色的就可能被清除
删除写屏障
    被删除的对象，如果自身为灰色或者白色，那么被标记为灰色，等到下次GC再处理（弱三色不变式 保护灰色对象到白色对象的路径不会断）


详细流程如下
    1.所有对象都是白色的
    2.从根对象进行标记，如果有子对象则当前对象是黑色，子对象为灰色（这个时候多线程并发），此时程序可用，
        当这个时间段有对对象进行新增/修改/删除时，会有写屏障，把对象改为黑色，父对象改为黑色 （避免无法触发新对象为灰色，父对象为黑色）
    3.标记完成后进行遍历扫描，此时程序不可用，扫描所有不可达的对象
    4.执行清理，清理完程序可用

本来整个过程是需要暂停程序不可用的，为了减少程序不可用的时间，优化如下
    1.在标记过程中是多线程进行处理，有子对象则标记为黑色，当前对象标记为灰色
    2.由于标记过程中程序可用就有可能数据会修改，那么对修改的数据及对应的父对象修改为黑色及灰色保证本次GC不会受到影响
    3.在扫描时跟清理时程序才正在不可用，缩短暂停时间提高效率