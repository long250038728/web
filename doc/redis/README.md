### 缓存一致性
不一致的两个根源
    并发问题（由于缓存只是起到辅助作用，MySQL必定是第一考虑，此时缓存的更新跟删除就要考虑如何配合）
        更新  事务A更新数据库后，事务B也更新了数据库后，事务B比事务A先刷到缓存
        删除  事务A更新数据库后，删除缓存，
            1.读取发现缓存未命中获取数据库更新缓存，此时又有一个事务更新同时删除缓存，此时插入的数据还是之前老数据
            2.此时如果还未删除成功就有读取缓存，此时读到的数据已经是老数据
    部分失败
        更新/删除  事务A更新数据库后，更新/删除缓存失败时，缓存读取的还是老的数据

使用缓存或其他中间件，必定有数据不一致的问题，如无法容忍短期不一致，那就不要用缓存（异构中间件）
    不一致性只是时间问题————多长的不一致（先更新数据库后删除，延迟一定时候在删除————延迟双删）
    
处理方案
    1.把相关的通过负载均衡到同一个服务器上（尽可能是一致性hash），通过采用singlefight处理成一个队列处理（kafka分区的概念）
    2.缓存失败的问题，尽可能设置高可用的缓存中间件，同时通过消息队列延迟删除(增加去数据库读取正确数据的机会)
    


### 缓存类型
Cache Aside (默认：旁路缓存)
1. 判断是否有缓存
2. 有则返回，无则查数据库（采用singlefight：本地locker的概念）插入缓存（可同步可异步）
3. 返回数据

Cache read through（只管读缓存类）
* 到缓存类中读数据，当缓存不存在的时候，内部有方法去获取（依赖注入）

Cache write through（只管写缓存类）
* 到缓存类中写数据，内部有方法去写入到其他（依赖注入）

Cache write back（只写缓存）
* 所有的东西都是直接操作缓存，等到某个时候写入到其他（依赖注入）————秒杀扣库存



### 缓存三个注意事项
缓存穿透（1.对参数进行判断  2.对无数据的缓存值设置一个默认值）
* 数据库也没有该数据，缓存也没缓存空值，导致每次都要去数据库获取同时还要消耗一次redis请求

缓存击穿 （可通过singleflight解决）
* 一个热点数据突然过期了，大量的请求直击数据库

缓存雪崩（可对key的过期加一个随机时间，避免大量key同时过期）
* 大量的缓存过期，大量的请求直击数据库————缓存预热的场景

`
为什么需要缓存：避免同时大量请求到数据库
解决思路     ：避免同时大量请求到数据库
`

---

## 数据结构

* string      简单动态字符串      
* set         整数数组    hash表     
* hash        压缩列表    hash表
* list        压缩列表    双向链表    （list  hash  sorted 用压缩列表是为了能快速知道位置及大小）
* sorted set  压缩列表    跳表


数据量小的可以通过整数数组或压缩列表一个个遍历查找
* set                             用整数数组（数据是int类型才用这个，如果中间有string就会转换为hash表）
* hash \ list \  sorted set       用压缩列表
数据量大的话（每个小于64字节 或 512个）
* hash \ set   用hash表
* list        用双向链表
* sorted set  用跳表


1. 简单动态字符串： 如果是int类型直接存值，如果是string类型存的是string的指针地址

2. 整数数组: 就是一个普通的数组（为什么用整数表示因为我们一般用下标0，1，2来找，只存放的是具体值而不是entry）

3. 压缩列表：其实也是一个数组，只是表头有三个字段（表长度，最后一个的偏移量，数量），表尾巴有个结束字段，还有一个更重要的是他是紧凑的，可以每个对象存放不同的字节长度
    找第一个和最后一个可以通过三个字段计算偏移量得到数据
    找key中的count可以直接获取字段
    其他元素就只能遍历

4. 双向链表：开辟连续区域数据量大的话有很多碎片，只能通过链表把前后关联无需开辟大空间

5. hash：开辟一块区域的内存，通过对数据的key进行hash值计算求余，算出在哪个hash桶中，数量量大就会导致hash冲突。通过渐进式hash处理
   1. 开启另外一个连续区域内存（比之前大一倍）
   2. 对数据的key进行hash值计算求余
   3. 移动到新的内存 (一次性全部迁移有性能问题，通过处理请求的同时顺带迁移————按照偏移从0开始每次移动一部分)
   4. 全部迁移完销毁之前的连续须臾内存

6. 跳表：与B+树结构类似，通过第一层进行遍历，比当前值大则找下一个，如果比当前值小那就找上一层的下层指针，最后的一层遍历next指针及对比值，



