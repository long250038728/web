1. 要有一定的理论知识储备
    熟悉设计原则，思想，编码规范，设计模式，运用前人的智辉结晶。
2. 一定要刻意练习
    理论知识都学过，但是往往很难应用到实际中，走马观花，如果知识没转化到自己身上，学了也没用
3. 要有代码质量意识，设计意识
    要考虑哪些会扩展，哪些会变，这样编写会不会导致以后难维护，新增功能难处理。


设计模式用的是解耦（把代码拆成单一的小类，满足高内聚低耦合的特性），解决代码复杂性问题。
    创建型：将创建和使用代码解耦
    结构型：将不同功能代码解耦
    行为型：将不同行为解耦




每个设计模式都应该由两个部分组成，如果只是单纯的关注解决方案，就会产生大部分模式看起来相似的错觉
1. 应用场景
    则这个模式可以解决哪些问题。设计模式主要是区别于设计意图/应用场景
2. 解决方案
    设计思路和具体的代码实现


工厂模式、策略模式及命令模式的区别：
    策略模式Strategy
        ———————通过对象方法声明一个属性=》对象(基类)，外部客户端调用策略对象方法，策略方法调用内部对象(基类)方法
        ———————只需要了解策略对象的对外方法，策略方法内部调用的是简单工厂方法，只是不返回对象，而是成为内部成员变量
        侧重的是”策略“或”算法“这个特定的应用场景
        用来解决运行时一组策略中选择不同策略的问题

    工厂模式Factory (简单工厂又称 static Factory 故是通过static函数返回对象)
        ————————通过静态方法返回对象(基类)，外部客户端调用基类对象方法 
        ———————-需要了解工厂的对外方法，及对象(基类)的方法
        侧重封装对象的创建过程，这里的对象没有任何业务场景的限定

    命令模式(不同的命令具有不同的目的)
        命令模式则是不同的命令具有不同的目的，对应不同的处理逻辑，并互相不可替换

代理、桥接、装饰器及适配器的区别：
    在不改变类的情况下，通过的抽象接口/(抽象对象/继承)的方法，内部是调用 “传入的对象”或 “parent” 的方法的前后进行处理。
    代理更多的是为了“代理 权限判断 转发” ，装饰器更多的是为了“增强功能 多个”

        代理模式Proxy（做些额外的东西，比如log，埋点，跟业务无关的事） 
            只要是控制访问，而非加强功能。

        装饰器模式Decorator(加强功能)
            增加多个功能
            装饰器模式对原始类功能的增强


    桥接模式(接口与实现分离)
        将接口与实现分离，让他们可以较为容易，也较为独立的改变

    适配器模式（统一功能相同方法名不同的适配） *提供与原始类不同的接口
        事后补救的策略，提供与原始类不同的接口



观察者模式、责任链模式区别
    观察模式跟责任链模式也是做监听后进行触发，
        观察者处理不会影响到其他观察者
        责任链是会判断是否进行下个递归处理







1.创建型                
********1.工厂：多个相同功能不同类型创建放在一起  	  						   单据
		2.单例：全局只有一份，一般不随意修改）    							   配置
********3.建造者：需要传多个参数的构造方法       							  请求参数，仓储层sql构建，
		4.原型：需要复制一份类似的数据          							 复制慢操作的对象（能不从数据库，密集计算类型的）	


2.结构型(改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展) 
********1.代理：用于增强功能额外	    	                                缓存等
********2.桥接：实现与抽象分离 			                    			    实现与抽象分离
********3.装饰器：对原始类进行多个增强的装饰		                          开闭原则,新加功能不影响原先类功能，可用这个方法    
********4.适配器，用于组装或通过相同接口调用不同业务相同功能                     对已有业务进行合并处理（可以通过桥接的方式或工厂的方式）
		——————————
********5.门面：把多个接口/对象组合成一个接口（多个接口是为了单一责职）            接口合并、仓储层的处理（内部需要调用多少个表不管）
		6.|组合
		7.|享元


3.行为型（行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使得我们的代码更加地清晰）
********1.观察者：一个地方动了其他地方要处理                                           同时处理多个业务（消息队列）    广播
********2.模板：把一些东西封装起来放在父类，只提供某几个方法由子类进行个性化处理             功能复杂，给子类提供部分接口实现（依赖反转）
********3.策略：侧重的是”策略“或”算法“这个特定的应用场景，相同的目的，不同的实现            封装算法（如都是加密/排序/条码生成算法）
********4.职责链：通过数组或链表的方法把需要处理的方法通过链的方式进行下去                  同时处理多个业务（链表、数组）   队列
		5.状态：把每个处理的实现单独实现。在实现函数中把返回一个新的对象。（面向对象）        
		6.迭代器：forearch就是迭代器的一种方式，（可以惰性解析/处理）
		———————————
		7.访问者:为了避免不断添加功能导致膨胀把这些业务抽离出来，定义在独立的访问者类中       桥接模式相同（可用工厂模式替代）
		8.备忘录: 用于防丢失，撤销及恢复等场景                                          
		9.命令:函数没办法作为参数传给其他函数，我们可以将函数封装成对象。
********10.解释器: 为某个语言或规则进行解析（比较少用）                                  把一个json进行解释后抽成独立对象/功能
********11.中介: 让把实现交给比别人处理                                               domain层处理
