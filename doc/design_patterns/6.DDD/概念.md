运用DDD设计思想实现的微服务边界确实清晰很多

要了解DDD
    首要任务就是要吃透DDD的核心设计思想，搞清楚DDD与微服务，中台之前的关系
    DDD强调领域模型和微服务的设计的一体性，先有领域模型才有微服务。
    中台的本质是业务模型，微服务是业务模型的系统落地。DDD是设计思想，指导中台建模和微服务设计


   DDD    =>   中台   =>   微服务 
 设计思想      业务模型      系统落地
架构设计方法                架构风格

DDD和微服务本质上都是为了追求高响应，从业务视角去分离应用系统复杂度的手段。都强调从业务出发
    合理划分领域边界，持续调整现有架构，优化现有代码，保持架构和代码的生命力

DDD关注业务领域边界，构建通用语言进行高效沟通，通过业务抽象建立领域模型，维持业务和代码的逻辑一致性

微服务关注运行时进程通信，容错及故障隔离，实现去中心化数据管理和去中心化服务治理，关注独立开发，测试，构建和部署


1.了解DDD必知必会的核心概念
2.DDD分层弄懂微服务架构直接的关系
3.设计与事件风暴完成领域建模和企业中台业务建模
4.DDD的战略设计和企业中台业务建模
5.深化微服务架构设计的原则和注意事项。


-------------------------------------
单机  =》 集中式 =》分布式微服务

微服务的拆分困境产生的根本原因是不知道业务或者微服务的边界在什么地方
DDD的核心思想就是通过领域驱动设计方法定义领域模型
    从而确定业务和应用的边界，保证业务模型与代码模型的一致性

DDD
    处理高度复杂领域的设计思想（设计方法论，边界划分把负责业务领域简单化）
    分离技术实现的复杂性，围绕业务概念构建领域模型来控制业务的复杂性

战略设计（从业务视角出发，建立业务领域模型，划分领域边界，建立通用语言的界限上下文）
    建立领域模型，领域模型可以指导微服务的设计和拆分。事件风暴是建立领域模型的主要方法
    采用用例分析，场景分析和用户旅程分析。尽可能全面不遗漏的分解业务领域。梳理领域对象之间的关系
    事件风暴会产生很大实体，命令，事件等领域对象。我们对领域对象从不同维度进行聚类
        形成聚合，限界上下文等边界，建立领域模型，这是收敛的过程

    聚合根，实体，值对象  =》 聚合(逻辑边界)  =》 限界上下文（物理边界） =》 领域（领域或子领域）
    

战术设计（从技术视角出发，侧重技术实现，完成开发和逻辑）
    集合根，实体，值对象，领域服务，应用服务 和资源库等代码逻辑的设计和实现
    从业务模型向微服务落地的过程，我们会将领域模型中的领域对象与代码模型中的代码对象建立映射关系
        将业务架构和系统架构进行绑定。当我们响应业务变化调整业务架构和领域模型时，系统架构也会发生调整，并同步建立新的映射关系


-------------------------------------

领域：
    活动
子域：
    营销活动
子子域（限界上下文）：
    盲盒抽奖活动
聚合：
    1.盲盒抽奖活动配置           (配置服务不影响参与及汇总)
    2.参与并下单盲盒抽奖活动      (参与服务不影响配置及汇总)
    3.盲盒抽奖统计              (配置服务不影响参与及配置)    


根据业务操作和行为找出实体，或值对象，进而将业务关联精密的实体和值对象进行组合，构成聚合，
再根据业务语义将对个聚合划定到同一个限界上下文，并在界限上下文内完成领域模型建模



领域 
    领域就是确定范围（边界），DDD按照一定的规则对业务进行细分，当细分到一定程度，就会限定边界
        在这个边界建立的领域模型，解决对应的业务问题，

子域
    领域可以划分出来多个子领域，每个子领域对应更小的问题或业务范围
    通过领域划分，区分不同子域在公司内的不同功能属性和重要性，从而采用不同的资源投入和建设
    1.核心域
    2.通用域
    3.支撑域
    
限界上下文
    通用语言：在事件风暴过程中，通过团队交流达成共识，能够简单，清晰，准确的描述含义和规则的语言解决交流障碍这个问题
        在通用语言的名词可以给领域对象命名中如商品，订单等
        动词表示一个动作或事件如下订单，已付款等
    限界上下文：（限界：领域的边界    上下文：语义环境）：
        语言都有它的语义环境，在通用语言也有它的上下文环境，为了避免同样的概念或语义在不同的上下文环境中产生歧义、
            通过领域的限界上下文，我们就可以在统一的领域边界内用统一的语言进行交流
    领域可以拆分多个子领域，一个领域相当于一个问题域，领域拆分子域的过程就是把大问题拆分小问题
    子域还可以根据需要进一步拆成子子域，拆到一定程度后，子子域的领域边界就可能成为限界上下文的边界



聚合
    实体和值对象是很基础的领域对象，
        实体一般对应业务对象，他具有业务属性和业务行为
        值对象主要是属性的集合，对实体的状态和特征进行描述，但实体和值对象都只是个体化的对象，他们的表现出来是个体的能力
    让实体和值对象协同工作的组织是聚合，他来确保这些领域对象在实现共同的业务逻辑，保证数据的一致性
    领域模型最底层的边界，可以拆分微服务的最小单位，一个为微服务可以多个聚合

聚合根
    避免由于复杂的数据模型缺少统一的业务规则控制，导致聚合，实体之间数据不一致问题
    如果把聚合当成组织，那聚合根就是负责人，聚合根也称实体，它不仅是实体还是聚合的管理者
    聚合根是实体，有全局唯一标识，有独立的生命周期，一个聚合只有一个聚合根
        聚合根和聚合根之间是通过id关联的方式实现聚合之间的协同


值对象
    实体
        有一类对象，他拥有唯一标识符，且经历各种状态变更后仍能保持一致。重要的不是其属性，而是延续性及标识
            跨越甚至超出软件的生命周期
        战略设计：实体领域模型的一个重要对象，领域模型中的实体是多个属性，操作或行为的载体。
            按照一定的业务规则将依存高度和业务关联紧密的国歌实体对象和值对象进行类聚，形成聚合。
            （实体和值对象是组成领域模型的基础单元）
        代码模型：实体的表现形式是实体类，这个类包含了实体的属性及方法。（充血模型）
            与这个实体相关的所有业务逻辑都在这个实体类中的方法实现，跨多个实体的领域逻辑则在领域服务中实现
        实体运行形态：
            实体以DO的形式存在，每个实体对象有一个唯一的ID,我们可以对一个实体对象进行多次修改，由于他们拥有相同的ID，他们依旧是同一个实体，比如商品是商品上下文的一个实体，通过商品的唯一id来表示，无论商品数据怎么变换，id不会变
        实体中的数据库形态：
            与传统数据模型设计不一样，DDD是先构建领域模型，针对事件业务构建实体对象和行为，再将实体和对象映射到持久化对象
    值对象
        没有唯一标识，只是数据的容器，没有业务逻辑，值对象是实体的一部分。为了简化设计，将比分相关的属性抽离成值对象。如果值对象发生改变，原来的值对象可以直接丢弃。值对象过多导致业务的缺失，影响查询性能
    实体可以修改，值对象不可修改只能替换，实体是实实在在的业务对象，值对象只是对对对象的描述，值对象依附于实体。


------
* 用户接口层controller：
  1. api对外暴露层
* 应用层server：（负责服务的组合，编排，转发，负责处理业务用例的执行顺序及结果的拼装） 很薄的一次，不应该有业务规则或逻辑，主要是面向用例和流程相关的操作
  1. 在领域层之上，因为凌雨辰包含多个聚合，他可也协调多个聚合的服务和领域对象完成服务的编排和组合
  2. 应用层也是微服务之间的交互通道，他可也调用其他微服务的应用服务，完成微服务之间的服务组合和编排
  3. 不要把本应该放在领域层的业务放到应用层，因为庞大的应用层会让领域层失焦。
* 领域层domian：
  1. 实现核心业务逻辑，通过各种校验手段保证业务正确性。表达业务概念，业务状态和业务规则
  >聚合根，实体，值对象，领域服务等领域模型中的领域对象
   领域模型中的业务逻辑主要是由实体和领域服务来实现，其中实体会采用充血模型实现
   实体和领域服务在实现业务逻辑上不是统计的，领域模型中的某些功能，单一实体（值对象）不能实现时，领域服务就马上出现，
    他可以组合聚合内的多个实体，实现复杂的业务逻辑
* 基础层：
  1. 贯穿所有层，提供通用的技术和服务，包括第三方工具，驱动，消息中间件，网关，文件，缓存及数据库等
        采用依赖倒置设计，封装基础的资源服务，实现应用层，领域层与基础层的解耦，



分层架构最重要的原则（每层只能与位于其下方的层发生耦合）
    推荐： 严格分层架构中，领域层只能被应用层调用，应用层只能被用户接口处调用，服务是逐层对外封装和组合的依赖关系星期
    1、严格分层架构
        任何层只能跟直接下层产生依赖
    2、松散分层架构    
        允许与任意层产生依赖

    值对象 =》 实体 =》 集合根 =》 聚合 =》 限界上下文
    值对象和实体的简单更变，一般不会让领域模型和微服务发生大的变化，但聚合的重组或拆分却可以。
        聚合内业务功能内聚，能独立完成特定的业务逻辑，聚合的重组或拆分，势必会引起业务和系统功能的变化。
    好的聚合和代码模型的边界设计，会让你快速应对业务变化，轻松实现领域模型和微服务的演进，

    1.层间松耦合，可以关注本层的设计，不用关心其他层，也不必担心自己的设计会影响到其他层，降低了层与层之间的依赖
    2.可以使结构更加清晰，升级和维护更加容易。
        修改某层的代码层面，只要本层的接口参数不变，其他层无需改动
        本层的接口发送改变，也只影响到相邻的上层，修改工作量小且可以控制，不会带来风险

    单体架构为三层
        解决了代码间的调用复杂，代码职责不清楚，单分层是逻辑的概念，在物理上他是中心化的集中式架构，不适合分布式微服务
    DDD四层架构
        主要是发生在业务逻辑层和数据访问层
            1.引入DTO层，给前端提供更多可使用的数据和更高的展示灵活性（status =》 status_name）
            2.将业务逻辑服务拆到应用层和领域层，应用层快速响应前端变化，领域层实现领域模型的能力
            3.数据访问层和基础层之间，三层架构访问数据是DAO方式，DDD的数据库等基础资源访问，
                采用仓储层，通过依赖倒置实现各层对基础资源的解耦

            仓储：仓储接口及仓储实现
                仓储接口放在领域层中，仓储实现放在基础层


### 整洁架构：洋葱架构
整洁架构的层就想洋葱片一样，整洁架构里同心圆代表应用软件的不同部分.
    主要是依赖原则，定义各层的依赖关系，越往里面依赖越低，代码级别越高，越核心能力
从里到外依次
* 领域模型 ：
  1. 实现领域内核心业务逻辑。主体是实体，一个实体可以是一个带方法的对象，也可以是数据结构和方法集合
* 领域服务：
  1. 实现涉及多个实体的复杂业务逻辑
* 应用服务：
  1. 用户操作相关的服务组合和编排，业务流程规则
* 用户界面和基础设施:
  1. 用户界面（app web服务器） 
  2. 基础设施db 缓存 文件）

### 六边形架构： 端口适配器架构
应用是同个端口与外部进行交互的，这也会微服务架构下api网关盛行的主要原因
* 内六边形
  1. 核心业务逻辑（应用程序和领域模型）
* 外六边形
  1. 外部资源（app，web应用，及数据库资源）
* 仅同个适配器进行交互，他解决了业务逻辑和用户界面代码交错问题，很好实现前后端分离。

主要实现核心业务逻辑，但是核心业务逻辑也有差异
    有的业务逻辑属于领域模型能力，有的属于面向用户的用例和流程编排能力，

    领域层实现面向领域模型，实现领域模型的核心业务逻辑，属于原子模型
        它保持领域模型和业务逻辑的稳定，对外提供稳定的细粒度的领域服务，是架构的核心位置
    应用层实现面向对象操作相关的用例和流程，对外提供粗粒度的api服务，
        就想齿轮一样进行前台应用和领域层的适配。接收前台需求，随时做出相应和调整，尽量避免将前台需求传到领域层，应用层作为配速齿轮位于前台应用
    
    **需求变化无穷，但是变化的总是有据可寻的，用户体验，操作习惯，市场环境，已经管理流程的变化，会导致页面逻辑和流程的多遍，但总体来说，不管前端如何改变，在核心领域逻辑基本不会大变，所以领域模型相对稳定，而用例和流程会随着外部应用需求而随时改变。把握好这个规律，就知道怎么设计应用层和领域层

    通过分层的方式控制需求变化从里到外对系统的影响，从外向里收需求影响逐步减少，
        面向用户的前端可以快速响应外部需求进行调整和发布，灵活多遍
        应用层通过服务组合和编排来实现业务流程的快速适配上线，减少传导到领域层的需求，保持领域层长期稳定
   

------
```
Interfaces 用户接口层
    存放用户接口与前端交互，
        处理用户发送过来的请求，解析参数，传输给application层
        返回Application层处理后的数据

Application 应用层
    存放应用服务组合和编排相关的代码

Domain  领域层
    存放领域层核心逻辑的相关代码，共同实现领域模型的核心业务逻辑，聚合以及聚合内的实体，方法，领域服务和事件等
    Reposirory层（在微服务架构演进时，保证代码拆分和重组）
        他存放查询或持久化领域对象的代码，

Infrastructure 基础层
    存放基础资源的代码，如通用的技术能力，第三方软件包，数据库服务
```


controller =》  Service  =》 Domian =》 Reposirory


------