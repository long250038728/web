从JDK中学习知识（灵活应用设计模式）：
    1.真实的项目中，这些模式的应用更加灵活，代码更加自由
    2.不可生搬硬套，过于学院派，要结合实际情况，心中无剑胜有剑

    Calendar
        工厂模式（用来创建不同对象但相关类型的对象）
            提供了大量的日期相关的代码，提供GetInstance()工厂方法，根据timeZone和Locale创建不同的子类
            对使用者来说无需关心是Calendar的哪个子类。

        建造者模式（用于创建一种类型的对象，根据传入的参数不同定制具有什么不同的功能）
            通过setxxx来给对象进行赋值，在执行build把对象中的所有属性进行处理及判断。


    Collections
        装饰器模式（对原始类功能的增强）
            UnmodifiableCollection的构造函数接收了Collections对象，对他进行函数的包裹，重新实现，从代码的角度是典型的装饰器模式
        适配器模式（兼容老版本的接口）
            老版本JDK中提供了Enumeration类提供遍历容器，在新版本JDK用Iterator类实现，为了适配以前的接口，Enumeration内部的处理方式改为用Iterator实现
        模板模式（把一些公共的逻辑放在父类，提供一部分接口给子类实现，提供灵活扩展）
        策略模式（策略的定义，创建，及使用）
            1.通过工厂模式创建
            2.使用的时候是动态非确定
        观察者模式（注册，广播）
            1.观察者进行注册
            2.当被观察者有变动，遍历之前注册观察者列表中，执行观察者之前注册的函数
        单例模式
            runtime实例，用于查看jvm状态及行为，进程内唯一，所以比较适合设计为单例。
        享元模式
            int string 他们相同的值共享同一个内存地址
        职责链模式
            拦截器，过滤器等功能都是用该模式




从unix中学习知识（处理大型项目）：
    1.封装跟抽象
        封装了不同设备的访问细节（隔离复杂性）
        抽象了统一文件的访问方式（简易上层代码的编写）
    2.分层及模块化
        模块化能独立维护，聚焦一个独立的高内聚开发
        每一层都封装实现细节，暴露抽象接口，每一层都能重新实现，不影响其他层的代码
        （把容易复用，跟业务无关下层，把容易变动的移到上层）
    3.基于接口通信
        尽可能抽象，尽可能少涉及实现细节
    4.高内聚低耦合
        内聚好，耦合小，在阅读修改代码时，无需了解其他模块或类的代码
    5.为扩展设计
        提前预留扩展点（开闭原则），基于扩展而非修改

    1.执行编码规范
    2.编写高质量的单元测试
    3.code review
    4.开发未动，文档先行
    5.持续重构
    6.对项目进行拆分






从Google Guava中学习知识（开发通用模块）：
    1.通用功能模块
        1.善于发现 ，抽象的能力
        2.发现非业务，可复用的功能点，进行抽象出来
        3.复用与业务无关
            
    2.函数式编程（函数无状态，内部的都是局部变量，离开函数即消失）
        以函数作为组织代码的单元，数据与方法相离   
        y = f(x)






从spring中学习知识
    利用框架可以解耦业务和非业务的开发，让程序员聚焦在业务开发上。
    隐藏复杂的实现细节，降低开发难度。规范开发，简单学习成本和维护成本。
    
    将一些非业务的代码开发为框架，在项目复用，节省开发时间，
    同时将多个项目的验证，比起每个项目重新开发，减少开发及学习成本。

    1.约定优于配置
        配置复杂繁琐，需要配置每个controller及对应的url等
            注解：
                在指定类上使用指定注解来代替xml配置
                    在controller类或接口上标注url
                    使用@Transaction注解表示支持事务等
            约定：（约定优于配置）
                如表名跟model文件名相同
                ORM中的属性与表字段名称保持相同
                用String对应数据库的varchar，long对应bigint

    2.低侵入，松耦合
        低侵入意味着当我们替换一个框架的时候，对原有业务修改很小。
        
        通过AOP的方式加入非功能性，如果分散在代码中，删除跟修改的成本就变得很高
            请求日志，数据采点，安全校验，事务等

    3.模块化，轻量级
        IOC功能进行模块化，通过分层，模块化让他们成为相互独立的功能，模块之前，仅有上层对下层的依赖。
        当需要单独使用一个小功能时无需引入大量东西。

    4.再封装，再抽象
        封装各种常用的功能模块，还对主流的中间件，系统访问类进行抽象及封装，提供更统一的访问
            如Cache，不在依赖具体的Cache实现方式。在不修改代码的情况下，实现不同Cache的切换



从MyBatis中学习知识(权衡性能，易用性，灵活性)
    约定优于配置（定义了接口和sql语句的映射，没有显示的把类与数据库字段映射）
    易用性代表损失了一定的性能（不可自定义，只是傻瓜的装换不够灵活）

    MyBatis
        自己编写sql，把方法跟sql做映射，更灵活（能优化————性能）
    Hibernate
        更加高级，根据业务生成sql代码（自动生成，没有针对性优化），易用性

    


    