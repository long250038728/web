SOLID
S：单一职责原则 (不要设计一个大而全，应该颗粒度小，功能单一的类)
O：开闭原则原则 (新加功能时不应修改已有的函数，需要新增，已保证不影响到之前已经反复测试的功能)
L：里式替换原则（继承及多态，子类替换父类时，不应破坏原有的入参，出参，报错，语义，功能等）
I：接口隔离原则（抽象及封装，每个函数或类只需提供单一功能的函数或返回值。应该隐藏细节不应该让调用者调用过于细节的接口）
D：依赖反转原则 (逻辑都封装到框架中，只提供少部分接口，程序员只在这些接口处理逻辑，如模板模式)

KISS原则（尽量保持简单）
YAGNI原则（不要过度设计）
DRY原则 （当语义重复时，相同或不同代码需要抽离到一个地方）
LOD迪米特法则(要实现高内聚低耦合)


##单一职责：
    一个类只负责一个职责或是一个功能。不要设计大而全的类。颗粒度小，功能单一的类。
        1.不同的应用场景，不同的阶段的需求背景下，对一个类的职责是否单一的判断可能是不一样的
        2.可以先写一个粗粒度的类，满足业务需求，随着业务发展，粗粒度越来越大，这个时候我们就拆成更细粒度的类


##开闭原则(扩展开放，修改关闭)
    添加一个新的功能应该是在现有代码基础上扩展代码，而非修改已有代码
    他没有破坏原有的代码的正常运行，没有破坏原有的单元测试，

        当加一个新的功能的时候，不应该改动到之前已有的函数（之前的函数已经做了大量的测试及验证）
            应新增模块，类，方法，属性，而非修改
        所以尽可能的写代码的时候做到灵活的扩展


##里式替换原则(继承与多态)
    子类对象能够替换程序中的父类对象出现的任何一个地方，并保证原来的程序逻辑不变及正确性不被破坏
        按照协议设计
            子类要遵循父类的行为约定。父类定义了函数的行为定义，子类可以改变函数的内部实现逻辑，单不改变原有行为的约定。
                行为约定包括：输入，输出，异常的约定，甚至包括注释中所列的特殊说明。

    多态与里式替换原则的区别
        多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法，
            他是代码实现的思路
        里式替换原则
            他是一种设计原则，用来指导基层关系中子类该如何设计。
                子类的设计要保证替换父类的时候，不改变原有逻辑及不被破坏原有的正确性

    哪些代码违背里式替换原则
        1.sortOrderByAmount()对订单进行按金额排序，子类重写按照日期排序，但是按照函数名理应按金额排序，违背了里式替换原则的（函数功能性约定）
        2.某个函数运行出错返回的是null，子类重载后运行出错返回Exception，违背了里式替换原则的（输入，输出，异常的约定）
    

##接口隔离原则（抽象及封装）
    客户端(接口的调用者、使用者)不应该强迫依赖它不需要的接口

    单一职责原则
        针对的是模块，类，接口的设计
    接口隔离原则 
        1.他侧重接口的设计
        2.他思考的角度不一样，他提供了判断接口是否职责单一的标准：调用者如何使用接口来间接判断
            如果调用者只使用部分接口功能，那接口的设计就不够职责单一

    理解接口隔离原则 
        1.理解为接口集合
            如果部分接口只被部分调用者使用，我们需要把这部分的接口隔离出来
        2.理解为单个api
            部分调用者值需要函数的部分功能，那我们把函数单独才分颗粒度更细的多个函数
        3.理解为OOP的接口
            接口设计尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数


##依赖反转原则(主流程交给框架去处理，框架只透露几个函数可实现，模板模式等)
    1.控制反转
        控制反转是一个比较笼统的设计思想不是一种具体的实现方式。
        一般来指导框架层面的设计，流程的控制权从程序员反转给了框架（框架提供某些函数，你这边只能在这函数中处理，不能处理其他功能）
            控制指对程序执行流程的控制
            反转指在没有框架之前，程序员自己去控制整个程序的执行，在使用框架后，整个程序的执行流程通过框架控制
    2.依赖注入
        依赖注入与控制反转恰恰相反，他是一种具体的编程技巧
            我们不通过在内部new的方式创建依赖对象，而是在外部创建好，通过构造函数及函数参数等方式传到类中使用
    3.依赖反转原则 
        与控制反转相似，主要是用来指导框架层面的设计，高层模块不依赖底层模块，他们共同依赖同一个抽象。抽象不要依赖具体细节
            调用者属于高层，被调用者属于底层




KISS原则（如何做）
    keep it simple and stupid
    尽量保持简单

YAGNI原则（要不要做）
    你不会需要它（不要去设计当前用不到的功能），不要过度设计

DRY原则
    不要写重复代码(执行重复/逻辑重复*)(代码相同功能不同不违反DRY,函数名不同但是语义/功能相同违反DRY)
        实现逻辑重复但功能语义不重复 不违反DRY
        实现逻辑不重复但功能语义重复 违反DRY
        代码执行重复 违反DRY

LOD迪米特法则
    高内聚，低耦合。迪米特法则也叫最小知识原则（每个模块只应该了解与他相关的模块）

    高内聚
        把相近的功能应该放到同一个类中，不相近的则不放在同个类中
            相近的功能往往会同时修改，集中会让代码好维护
    松耦合
        类与类之间的依赖关系清晰，即使两个类有依赖关系，一个类的代码改动不会影响依赖类的改动
            依赖注入，接口隔离，基于接口而非实现编程，迪米特法则都是为了实现松耦合
        


单一职责：针对的是单个接口的设计思想
迪米特法则：针对的是接口之间的关系出发
基于接口而非实现：针对的是使用者的角度

