## 服务间的调用
* 同步(请求-响应方式)
  * http(适合对外提供API)
    1. 有成熟的体系生态(有广泛的工具、库和框架支持，易于集成和使用)
    2. 适合更多的介入/简单(弱类型定义)不受约束，可能会导致传递不合规数据或者遗漏必要参数，求及返回只是通过JSON便于查看和调试
  * grpc (需要高效传输、强类型定义.在http的基础上封装多一层 序列化，双向流式，负载均衡等)
    1. 通过二进制等序列化方式效率更高
    2. 通过IDL进行通信(强类型定义)，对接口及参数进行约束,通过编译器能及时检测结构破坏性变更
    3. 支持双向流式通讯
    4. 提供负载均衡，服务发现等机制
    5. 提供更多的适用微服务的状态码和错误处理机制
* 异步
  * 事件驱动消息中间件 (kafka/rocketMQ等)
    1. 对消息进行不丢失的问题(持久化,集群等)
    2. 实现多个消费组同时消费问题。同一消费者组内仅消费一次的功能
    3. 实现消息"仅消费一次"的场景(需要消费者处理幂等性)
    4. 额外功能如失信队列，延迟队列，事务队列，消息重放等


## GRPC IDL
服务间的变动(尽可能避免破坏性——结构性与语义性)
  * 接口/字段只增加不删
  * 使用向下兼容的技术(protoc对每个字段都有字段编号，新增字段对客户端不影响)
  * 应该显式的定义接口/字段(对变更可以进行对比)
不得不破坏性修改
  * 检查接口/字段变动的服务同时发生改变(构建)
  * 共存不兼容的微服务版本(v1版本的服务跟v2版本的服务——————如AB发布)
  * 公开新接口并模拟旧接口(v1,v2版本的接口、老接口转发到新接口即可知道哪些接口需要淘汰) **最简单也问题最少
  * 公共代码库修改时需要向下兼容(v1,v2版本的接口类似)

## 服务注册/发现