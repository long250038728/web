## 目录

- [流量治理](#流量治理)
    - [服务容错](#服务容错)
    - [容错策略](#容错策略)
    - [容错策略设计方案](#容错策略设计方案)
    - [熔断和降级之间的联系与差别](#熔断和降级之间的联系与差别)
- [限流](#限流)
    - [如何处理](#如何处理)
- [总结](#总结)

---

## 流量治理
某个服务无法正常提供服务，一个点层层传递导致上游服务有关的服务不能用导致雪崩效益
某个服务处理能力有限。一个点层层传递导致上游服务有关的服务不能用导致雪崩效益

### 服务容错
分布式系统本身是不可靠的(节点宕机，网络中断，程序崩溃)

### 容错策略
调用失败时处理方案
1. 故障转移(Failover): 如果调用出现故障不会返回失败，切换到`其他副本`重试(需要考虑次数)(需要幂等)
2. 快速失败(Failfast): 有些业务`不允许故障转移`，是因为他是非幂等性的，多次重试可能会产生脏数据
3. 安全失败(Failsafe): 如一些日志写失败等`非业务`的影响的，则不处理返回失败
4. 沉默失败(Failsilent): 默认当服务提供者一段时间内都无法再提供服务，`不再提供流量分配`。等后续再熔断尝试
5. 故障恢复(Failback): 当调用失败后后续通过消息队列`异步重试`(需要幂等)

调用失败前考虑的处理方案
1. 并行调用(Forking): 一开始就向`多个服务发起调用`，有一个成功返回即可(需要幂等)
2. 广播调用(broadcast): 与并行相对应，但要求所有的都应该`都返回成功`才算成功


### 容错策略设计方案
1. 熔断器 (快速失败的设计方案)
   * 会持续监控服务的返回成功，失败，超时，拒绝等各种响应。当错误达到一定阈值时就会变成open状态，此时后续对他的请求会直接，之后访问的都会直接返回调用失败
   * 中间会有一个`半开状态`，此时会允许部分流量通过，监控一段时间后，再根据错误比例来决定是否恢复服务
2. 舱壁隔离(沉默失败的设计方案)
   * `超时`引起的故障是最可能影响到系统的全局风险（每个服务最大的线程池数）
3. 重试模式(故障转移/故障恢复的设计方案)
   * 如果不是关键的服务，一般不要把重试作为首选的容错方案，尤其不应该进行同步重试。
   * 仅对由瞬时故障导致的失败进行重试(像没有权限的失败就没必要重试)。
   * 具备幂等性的服务进行重试(POST请求是非幂等的；GET、HEAD、OPTIONS、TRACE请求应该被设计成幂等的)
   * 重试必须有明确的终止条件（重试次数，重试超时时间）

### 熔断和降级之间的联系与差别
熔断: 上游服务必须能够主动处理调用下游失败的后果，而不是坐视故障扩散
降级: 降级是不应该只是把异常信息抛给用户，而应该尽力想办法通过其他路径解决问题，比如把原本要处理的业务记录下来，留待以后重新处理是最低限度的通用降级逻辑。

---

## 限流
很难再设计之初就给出一个确定的结论，只能通过未来一段时间的预测来动态决定

### 如何处理
* 超额流量给出409返回码，或返回服务降级的逻辑
* 对于超额流量有什么指标
  1. 每秒事务数TPS(以事务原子性维度 ——— 一个请求有且只有一个事务) 
  2. 每秒请求数HTS(以请求维度 ———— 一个处理可能有多个请求) 
  3. 每秒查询书QPS(以查询数维度 ———— 查询，修改，新增等)
* 设计方案
  1. 计数器(固定窗口——固定时间)
  2. 计数器(滑动窗口——相对时间)
  3. 令牌桶(每一段时间发放一定的令牌（总大小也要控制，如果一段时间内没有人申请如果无限颁发，后续请求就会发现令牌很多起不到限流），能获取令牌代表没限流，获取不到代表限流)
  4. 漏桶(有个缓冲区队列，缓冲区未满就进入等待，如果满了就丢弃)
* 分布式系统限流问题
  1. 需要有中间件来记录（都会产生网络开销）
  2. 货币化改造，不把令牌看做是准入的标准，而是看成"货币额度"，在每个请求消耗一定的货币，在一定的时间内，货币额度用完就拒绝请求（只有额度为0时才去申请货币额度，减少申请的次数）


```
    动态（用得少） --- 根据服务当前状态动态（cpu，响应，错误率）
    静态         --- 一秒内能执行多少请求（令牌，漏桶，固定窗口，滑动窗口）
        令牌桶： 有一个往桶里放令牌，此时如果拿到了就能执行，拿不到就不能执行（channel）—— 返回错误（限流/熔断），返回默认值（降级）
        漏桶： 请求过来先排队,在队头放行，如果队列满了就不能进（channel）
        固定窗口：每个时间段为一个一个窗口，每个窗口给一定的数量,当扣减为0则代表获取不到，直到下一个窗口
            redis ： lua脚本（通过原子性操作 --）： 1.如果不在新增这个key并对这个key设置过期时间 2.如果--为0返回false 限流成功
        滑动窗口：通过当前时间-减去设定时间长度，获取窗口，取这个窗口内的数量，如果长度大于等于设定值，则代表无法获得，否则获取成功，插入队列（频繁插入判断删除)
            redis ： lua脚本 zremrangebyscore key -inf 当前时间戳-设定值（性能差）进行删除部分的数据 然后用zcount进行获取个数，同时用Zadd进行添加，socre为时间戳

    令牌桶:每秒有多少给令牌。拿不到就报错丢弃。（主动在自己如果拿不到就报错），解决突发流量，由于不等待则不是平滑流量 （是否能从chan拿数据）
    漏桶：以队列的长度先进入队列，等待获取资格（主动方在队列消费端），平滑流量并避免突发大流量对服务接口的影响 （是否能插入chan）
    固定窗口：一个时间段给出一定的数量，如果数量为0则获取不到，与令牌桶类似，但是是以固定时间为维度，如果上一个时间段还没处理完就过下一个窗口就会比较麻烦（是否能从 i-- >= 0拿数据）
    滑动窗口：当前时间往前推设定的时间，算出这个时间段的队列数量，如果小于设定值就获取成功，否则失败。平滑流量并避免突发大流量对服务接口的影响 
```

## 总结
1. 超时：当对下游服务请求未做超时处理时，假如默认超时时间为60s，此时有1000个请求，此时大量的请求阻塞占用连接数及系统资源导致系统不可用。应该合理的控制超时时间（如默认值5s，可通过配置或参数变动）
2. 重试：超时可能是部分服务器的故障，此时可以考虑重试机制或直接失败等容错机制。看需要考虑重试的间隔时间，重试的次数等。避免重试风暴
3. 熔断：知道下游的服务有问题时依旧还对下游的服务调用会加大下游服务的压力，同时当前服务也可能会受到影响。所以下游服务有问题次数超过阈值时，就应该不调用返回错误。
4. 降级：每次熔断错误都直接返回错误可能不太好，部分接口对于下游熔断错误不敏感的接口。可以返回一些默认值或是其他的值用户体验更好
5. 限流: 某个接口调用次数较大，避免恶意请求或避免服务/接口不可用。拒绝一部分请求