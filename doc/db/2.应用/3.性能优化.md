## 性能优化的思想
1. 最大化利用资源(尽可能利用各自优势发挥最大作用，如：在无状态支持横向扩展计算，NOSQL集群,异步等)
2. 最小化使用资源(尽可能减少资源的损耗，如：数据结构，算法，内存，顺序io,减少行扫描等)
3. 业务优先(尽可能贴合业务做优化，如：线程改携程处理，一次性申请大内存避免频繁内核切换等)


## 部署优化
1. 单机多实例（当单台服务器性能够用时可以用多进程部署多个mysql。单机性能已经足够支撑同时并不互相影响）
2. `NUMA`开启(百度查询)但稳定性差，
3. 使用 `tcmalloc/jemalloc` 可以减少碎片及内存管理(避免频繁申请跟回收)


## mysql优化
1. 设置semi-sync半同步(保证从库尽可能的同步到数据，但不需要全部从节点都同步成功才提交)
2. double write buffer。写入磁盘之前会首先将其写入一个双写缓冲区。这个缓冲区的作用是提供一个额外的保护层，确保`数据页`在数据库崩溃或系统故障时数据不会丢失或损坏
3. group commit (百度查询) binlog, redo log等
4. MySQL5.6之后 RR隔离级别，binlog_row_image=full （当事务内更新一行数据时发现与库里数据一致时就不更新，导致后面的读还是事务开始视图的值） 需要改为binlog_row_image=minimal
5. AHI 自适应HASH算法。对于频繁使用的数据建立hash索引可快速查找
6. change buffer 对二级索引进行更新，此时这个索引页不在内存中，那么久不用那么着急去更新，先写到change buffer中，等到后续获取二级索引时再刷脏页（如果写完马上读的这种效果就很差）
7. LRU 优化3/8 分为young,old块 (避免一些临时数据获取的数据落入young中,在old中再次访问再考虑到young区,如果两个大表NLJ可能会把数据放到young页)
8. innodb_io_capacity 用来设置系统每秒能够执行的 I/O 操作数的上限(太小机器性能过剩，太大认为系统处理能力强innodb会把刷盘刷脏页的频率提高但系统处理不来)。
9. time_zone=+8:00 或UTC或cached (默认是system此时系统读很慢)
10. skip_name_resolve 如果ip访问时还反查域名，明确ip访问设置禁用
11. 


## 应用层优化
1. 减少交互次数(避免每次都先判断连接是否断开或获取表字段)，索引下推也是层之间减少交互
2. 减少事务的持续时间（可减少锁等待及死锁）
3. 减少返回的信息
4. 减少握手的次数(长连接)
5. redis缓存
   * 异步: canal监听binlog后消息队列更新缓存（binlog是顺序串行）
   * 同步: redis se
6. 读写分离
7. 分表分库，分布式数据库