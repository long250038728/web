## 性能优化的思想
1. 最大化利用资源(尽可能利用各自优势发挥最大作用，如：在无状态支持横向扩展计算，NOSQL集群,异步等)
2. 最小化使用资源(尽可能减少资源的损耗，如：数据结构，算法，内存，顺序io,减少行扫描等)
3. 业务优先(尽可能贴合业务做优化，如：线程改携程处理，一次性申请大内存避免频繁内核切换等)


## 部署优化————最大化利用资源
1. 单机多实例（当单台服务器性能够用时可以用多进程部署多个mysql。单机性能已经足够支撑同时并不互相影响）
2. `NUMA`开启(百度查询)但稳定性差，
3. 使用 `tcmalloc/jemalloc` 可以减少碎片及内存管理(避免频繁申请跟回收)


## mysql优化
1. 设置semi-sync半同步(保证从库尽可能的同步到数据，但不需要全部从节点都同步成功才提交)
2. double write buffer(百度查询)
3. group commit (百度查询) binlog, redo log等
4. MySQL5.6之后 RR隔离级别，binlog_row_image=full （当事务内更新一行数据时发现与库里数据一致时就不更新，导致后面的读还是事务开始视图的值） 需要改为binlog_row_image=minimal
5. AHI 自适应hash算法(百度查询) 对比频繁使用的数据建立hash快速查找
6. change buffer 对二级索引进行更新，此时这个索引页不在内存中，那么久不用那么着急去更新，先写到change buffer中，等到后续获取二级索引时再刷脏页
7. LRU 优化3/8 分为young,old块 (如果两个大表NLJ可能会把数据放到young页)
8. innodb_io_capacity 告诉innodb这台主机的io能力有多大(百度查询)


## 应用层优化
1. 减少交互次数(避免每次都先判断连接是否断开或获取表字段)，索引下推也是层之间减少交互
2. 减少事务的持续时间（可减少锁等待及死锁）
3. 减少返回的信息
4. 减少握手的次数(长连接)