## 目录
- [读写分离](#读写分离)
- [读写分离实现的方式](#读写分离实现的方式)
- [读写分离的问题](#读写分离的问题)
- [sql流程解析](#sql流程解析)
- [腾讯云读写分离](#腾讯云读写分离)

--- 

## 读写分离
* 当单台服务的资源不足时(io 内存等),单机性能可以满足无需分库，可以通过读写分离来提高服务的吞吐量，读写分离的原理是主从复制，主库负责写，从库负责读，主库写完数据后，会同步到从库，从库再把数据提供给客户端。
* 当一些大查询时可以不影响到主库，可以通过读读节点进行获取


## 读写分离实现的方式
* 客户端自己实现
* 通过proxy实现


## 读写分离的问题
需要注意下面的名称 `主库`，`读库`，`从库`这几个的区别
* 一个请求怎么怎么选择的主库或读库，读库多个如何选择，能否指定主库或读库
  * 如果有begin开始，理论上需要读取最新数据，同时后续可能有更新的操作，所以应该是到主库
  * 在sql中如果有某个标识如就应该根据这个表示去走对应的库
  * 在多个读库之间负载均衡是通过`轮训`、`最少连接数`、`平均响应时间`等算法的考虑
* 如何解决数据的不一致怎么解决
  * 全局一致性: 强同步（所有的读库都完成了更新后主库才返回成功，性能差）
  * 事务一致性: 同一个请求写完读可能落到不同的库则通过等待同步后查询，超时则回主库查询（如果是为了全局读一致性也可以用这个方式，颗粒度可以维护到表级别，相同的表读才加上wait等待）
    * 执行更新后返回主库的位点信息`SHOW MASTER STATUS`，读库执行`SELECT MASTER_POS_WAIT(主库log_name,主库log_pos[,timeout])`阻塞等待同步，当超时去主库查询
    * 通过GTID的方式主库设置`SET SESSION session_track_gtids = OWN_GTID`执行语句后都会返回GTID,读库执行`SELECT WAIT_FOR_EXECUTED_GTID_SET(gtid_set,timeout)`
  * 业务一致性: 业务可以容忍不一致性(性能好，需要业务可以接受)————更新后在主库获取数据返回，另外一个业务端获取短暂不一致没关系
  * 业务一致性: 在客户端进行sleep操作（以前操作是通过新增后弹窗点确定再获取数据，中间的间隔时间已经同步完成）
* 主从切换，读库如何从新主库的哪里开始读取数据(使用GTID设置position位置)
  * 主从为了保证从节点尽可能与主库保持一致，把协议改为semisync半同步(指写到master后需要slave成功后才返回)
    * 提高主从的一致性，但是降低了吞吐量
    * `SHOW VARIABLES LIKE 'rpl_semi_sync%'; `查看semi相关的参数
    * `SET GLOBAL rpl_semi_sync_master_enabled = 1;` 设置主库的semi是否开启(主从都是on半同步 否则异步)
    * `SET GLOBAL rpl_semi_sync_slave_enabled = 1;`  设置从库的semi是否开启(主从都是on半同步 否则异步)
  

## sql流程解析
1. 客户端发送请求发送到proxy
2. 判断sql中是否有hint标识,如果有则访问具体的库
3. 判断是不是写请求，如果写请求有马上需要读同时可能会到读库去读确保数据一致则通过GTID或log_name/log_pos进行等待同步后读库获取，超时可回主库或其他读库同样的操作
4. 读请求通过负载均衡的方式访问读库


## 腾讯云读写分离
事务拆分功能
* 将一个事务中的读和写操作拆分到不同的实例上去执行
* 为了保证事务的读一致性可以使用位点信息/GTID等待同步的方式处理
读库读写属性
* 读写分离 (一个事务有读写，此时中的读是否命中到这个库)
* 只读 (只有读事务才会命中到这个库)
负载均衡
* 根据权重设置
* 自适应负载均衡 (读写分离理论上权重应该要小一点因为承担了写后读的压力)
hint强制指定实例
* 指定主库 /* to master */ 或 /* FORCE_MASTER */
* 指定读库 /* to slave */ 或 /* FORCE_SLAVE */
* 指定具体库 /* to server server_name */