## 读写分离
* 当单台服务的资源不足时(io 内存等),单机性能可以满足无需分库，可以通过读写分离来提高服务的吞吐量，读写分离的原理是主从复制，主库负责写，从库负责读，主库写完数据后，会同步到从库，从库再把数据提供给客户端。
* 当一些大查询时可以不影响到主库，可以通过读读节点进行获取


## 读写分离实现的方式
* 客户端自己实现
* 通过proxy实现


## 读写分离的问题
需要注意下面的名称 `主库`，`读库`，`从库`这几个的区别
* 一个请求怎么怎么选择的主库或读库，读库多个如何选择，能否指定主库或读库
  * 如果有begin开始，理论上需要读取最新数据，同时后续可能有更新的操作，所以应该是到主库
  * 在sql中如果有某个标识如就应该根据这个表示去走对应的库
  * 在多个读库之间负载均衡是通过`轮训`、`最少连接数`、`平均响应时间`等算法的考虑
* 写请求后，如何有马上读的请求怎么办。如何解决数据的不一致怎么解决
  * 强同步（所有的读库都完成了更新后主库才返回成功，性能差）
  * 业务可以容忍不一致性(性能好，需要业务可以接受)————更新后在主库获取数据返回，另外一个业务端获取短暂不一致没关系
  * 在客户端进行sleep操作（以前操作是通过新增后弹窗点确定再获取数据，中间的间隔时间已经同步完成）
  * 读库等待同步后执行，超时则回主库查询
    * 执行更新后返回主库的位点信息`SHOW MASTER STATUS`，读库执行`SELECT MASTER_POS_WAIT(主库log_name,主库log_pos[,timeout])`阻塞等待同步，当超时去主库查询
    * 通过GTID的方式主库设置`SET SESSION session_track_gtids = OWN_GTID`执行语句后都会返回GTID,读库执行`SELECT WAIT_FOR_EXECUTED_GTID_SET(gtid_set,timeout)`
* 主从切换，读库如何从新主库的哪里开始读取数据(使用GTID设置position位置)
  * 主从为了保证从节点尽可能与主库保持一致，把协议改为semisync半同步(指写到master后需要slave成功后才返回)
    * 提高主从的一致性，但是降低了吞吐量
    * `SHOW VARIABLES LIKE 'rpl_semi_sync%'; `查看semi相关的参数
    * `SET GLOBAL rpl_semi_sync_master_enabled = 1;` 设置主库的semi是否开启(主从都是on半同步 否则异步)
    * `SET GLOBAL rpl_semi_sync_slave_enabled = 1;`  设置从库的semi是否开启(主从都是on半同步 否则异步)
  

## sql流程解析
1. 客户端发送请求发送到proxy
2. 判断sql中是否有hint标识,如果有则访问具体的库
3. 判断是不是写请求/是否有begin等，如果写请求则访问主库。执行完返回GTID或log_name/log_pos记录本地
4. 通过负载均衡的方式访问读库，此时通过GTID或log_name/log_pos进行等待同步，如果未超时则在读库获取，超时可回主库或其他读库同样的操作
   * 由于主从同步需要时间，当能拿到过GTID或log_name/log_pos进行等待同步，如果未超时则代表已经同步(即读库已经有这部分的数据)过来。


## 腾讯云TDSQL