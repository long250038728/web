## 读写分离
* 当单台服务的资源不足时(io 内存等)，可以通过读写分离来提高服务的吞吐量，读写分离的原理是主从复制，主库负责写，从库负责读，主库写完数据后，会同步到从库，从库再把数据提供给客户端。
* 当一些大查询时可以不影响到主库，可以通过读读节点进行获取


## 读写分离实现的方式
* 客户端自己实现
* 通过proxy实现


## 读写分离的问题
需要注意下面的名称 `主库`，`读库`，`从库`这几个的区别
* 一个请求怎么怎么选择的主库或读库，读库多个如何选择，能否指定主库或读库
  * 如果有begin开始，理论上需要读取最新数据，同时后续可能有更新的操作，所以应该是到主库
  * 在sql中如果有某个标识如就应该根据这个表示去走对应的库
  * 在多个读库之间负载均衡是通过`轮训`、`最少连接数`、`平均响应时间`等算法的考虑
* 写请求后，如何有马上读的请求怎么办。如何解决数据的不一致怎么解决
  * 强同步（所有的读库都完成了更新后主库才返回成功，性能差）
  * 业务可以容忍不一致性(性能好，需要业务可以接受)————更新后在主库获取数据返回，另外一个业务端获取短暂不一致没关系
  * 在客户端进行sleep操作（以前操作是通过新增后弹窗点确定再获取数据，中间的间隔时间已经同步完成）
  * 等待延迟后执行，超时就主库查询
    * 执行更新后返回主库的位点信息`SHOW MASTER STATUS`，读库执行`SELECT MASTER_POS_WAIT(log_name,log_pos[,timeout])`阻塞等待同步，当超时去主库查询（**百度查询）
    * 通过GTID的方式主库设置`session_track_gtids = ON`执行语句后都会返回GTID,读库执行`wait_for_executed_gtid_set(gtid_set,timeout)`（**百度查询）
* 主从切换，读库如何从新主库的哪里开始读取数据(使用GTID设置position位置)
  * 主从为了保证从节点尽可能与主库保持一致，把协议改为semisync半同步（两个备库**百度一下半同步 ）

## 思考如何自己实现
#TODO

## 腾讯云TDSQL