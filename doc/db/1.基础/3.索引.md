## 索引
### B+树 为了提高查询效率，每添加一个索引就是添加一个B+树。
* 聚簇索引: 叶子节点key存放主键，value存放行数据  
* 二级索引: 叶子节点key存放索引列，value存放主键 （为了保证树结构尽可能小，后续获取数据需要回到聚簇索引找到行数据——回表）

### 主键要求
1. 尽可能占用空间小（索引能存放更多数据找得更快）
2. 有序自增避免插入导致页分裂(应该使用追加)

### 索引优化
1. 覆盖索引 （查询的条件及值都在索引上不需要回表————但是就会加大索引的大小需要权衡）—— Using index
2. 最左前缀原则 (可以减少索引的创建，当有一个索引(A,B),此时需要索引(A,B,C)是，就可以只保留索引(A,B,C))
3. 索引下推 (尽可能在innodb上进行判断减少返回server的机会)

### 索引的选择
1. 普通索引不用校验唯一性，所以修改/新增时不用校验唯一性。可以借助change buffer优化(减少随机读问题)
2. 唯一索引由于会校验唯一性，所以在锁的的力度会更小更好（不用查询下一个，中间也没有间隙。 只有行锁没有next_key lock）

### 索引失效
1. 在事务开启时中间有很多其他事务的修改(有undo log回滚)，二级索引需要回表优化器会考虑
2. 优化器对采样统计的`统计信息`中`索引基数`有误判断
3. 当使用order by id时可能认为id有序，所以考虑无需回表使用主键索引
4. 对索引字段进行函数操作（可能破坏树的有序性）
5. 隐式类型转换(类型是string，条件是int) ———— 会把字段字符串转为int
6. 隐式字符串编码转换(联表时常见utf8mb4和utf8)


### 如何使用正确的索引
1. 使用force index 强制使用，/** 但不推荐 **/
2. 引到优化器使用正确的索引.如order by /** 推荐 **/
3. 结合业务优化索引，整合多个索引合并
4. 对字符串添加索引时避免字符串过长（加大区分度）截取字符串（如果能使用前缀索引就直接用不能就保存到另外一个字段中），对该字段添加索引