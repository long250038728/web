# 数据结构与算法
数据结构顾名思义就是把一堆数据通过某种方式进行排列起来，其作用是为了快速的查找到想要找到的对象。如果数据是类似于文档的形式往后拼接的话，那么查找一个东西就需要一行行的查找此时查询效率极慢。
所以不同的数据结构对数据查询的时间复杂度是不同的。

数据结构与算法就是不断探索，满足下面的条件:
1. 数据一定有序，如果无序则无法进行对比查询
2. 该数据结构需要从时间复杂度O(N) 尽可能的演变到O(logN)或O(1)
3. 在数据结构中最重要的概念是 "时间换空间" "空间换时间"。


# 基本数据结构
### 数组
开辟一个连续的内存空间，存放相同类型的数据，根据数组起始指针找到其实位置通过offset偏移量乘以每个的长度获取对应的值。由于连续空间CPU的缓存机制，预读数组中的数据，所以访问效率更高
>值 = 开始位置 + 偏移量 * 每个长度

优点:
1. 可以通过偏移量快速找到对应的结点数据,时间复杂度O(1),如果遍历查询依旧是时间复杂度O(N)
2. 无需存放额外的数据字段

缺点：
1. 根据偏移量读取时需要判断避免数组越界
2. 声明时需要定义类型(确定每个的长度用于偏移量获取对应参数) 
3. 新增数据到k的位置时，需要k~n位置的往后挪动，时间复杂度O(N)
    * 当数据不需要有序时把数据放入k中，原先k位置的数据拼接到数组最后，时间复杂度O(1)
4. 删除数据k的位置时，需要k~n位置的往前挪动，时间复杂度O(N)
    * 当数据不需要有序/通过偏移量获取时把数据标记为已删除，等新增填充删除标记的位置，时间复杂度O(1)
5. 需要连续开辟一个连续的内存空间，需要扩容时需要手动处理。同时如果数组过大系统可能没有足够的连续内存空间则会导致内存不足
    * 高级语言中会进行封装一层如 go 的切片。同时扩容也会导致需要申请一个比之前大的内存空间然后进行迁移。性能及内存占用会有一定的开销

实现场景:
快速查找: 可以通过偏移量offset快速定位某个值，长度，二分查找
其他数据结构: 哈希

### 链表
通过零散的内存块串联起来。所以每个结点都应该存放额外的数据(prev指针，next指针)

由链表的形式演变出下面几种
* 单链表: 只有next指针可以找到下一个结点,时间复杂度O(1)
* 双向链表: 有prev指针，next指针可以找到上一个及下一个结点,时间复杂度O(1)
* 单向循环链表: 由于普通的链表最后的指针为null,循环就是需要把最后的next指针指向第一个，形成一个环形
* 双向向循环链表: 与结合双向链表及单向循环链表

优点:
1. 在新增/删除时无需挪动位置后面的数据
2. 在创建时无需提前申请一批内存大小，无需考虑扩容的问题。

缺点:
1. 无法通过偏移量快速找到对应数据
2. 由于连接是通过prev指针及next指针则需要存放额外的数据

实现场景:
LRU: 最近使用的放在链的头，淘汰删除链尾。
其他数据结构: 跳表，树，队列，栈，堆，图等

---


## 数组与链表扩展(栈与队列、hash及跳表)

### 栈
栈是可通过数组(顺序栈)或链表(链式栈)实现。主要的目的是实现先进后出的作用（只允许在一端插入和删除数据。）

1. 入栈: 当栈的空间未满时时间复杂度为O(1),当栈满时时间复杂度为O(N)是因为需要扩容进行搬迁的操作
2. 出栈: 在栈顶剔出时间复杂度为O(1)

实现场景:
1. 操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构,用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返
回之后，将这个函数对应的栈帧出栈
2. 表达式求值: 34+13*9+44-12/3 通过两个栈实现当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比
   较。
3. 括号是否匹配:(1+2)-4+(3-1)



### 队列
队列是可通过数组(顺序栈)或链表(链式栈)实现。主要的目的是实现先进先出的作用

1. 入队: 当栈的空间未满时时间复杂度为O(1),当栈满时可以考虑阻塞或丢弃(阻塞的话用另外一个队列处理)
2. 出对: 在栈顶剔出时间复杂度为O(1)

实现场景:
1. 消息队列(先进先出)


### 哈希
hash是通过数组的方式实现的。通过如hash(data)对数据求一个hash值，然后取模保存到对应的数组偏移位置上。为了满足时间复杂度O(1)。 hash经常用到数组及链表组合实现(链式法)。

hash冲突如何解决:
1. 开放寻址法(不开辟新的空间，往后找空余位置) 对空间有要求，查找会慢一点
   * 线性探测: 往后遍历找到空的地方进行存放(在删除时不能对数据进行删除只能标识，因为查询时hash冲突往后找空的，中间如果被清空就会导致停止认为不存在)
   * 二次探测：往后遍历找到空的地方进行存放(与线性类似只是 hash(data)+1²  hash(data)+1³ ... )
   * 双重散列: 通过hash2，hash3函数再次进行hash找到新的位置
2. 链表法(开辟新的空间) 对空间无要求，查找会更快
   * 新建一个链表的方式进行链式存储，时间复杂度从O(1) 演变为O(链的长度k)

渐进式hash扩容
当数据达到装载因子阈值时(如0.7),此时需要申请一块新的内存(大一倍或多少等),由于避免O(N)的时间复杂度，所以在查询或操作的同时顺便把原先的hash部分迁移到新的hash。在查询时先查询旧的hash，然后再查询新的hash

实现场景:
1. 通过hash快速查找/判断是否存储的数据，时间复杂度O(1)



### 跳表
跳表是通过链表实现，由于链表无法像数组一样通过偏移量查找对应的数据，同时无法判断当前的长度，中间位置是什么，所以通过加索引的方式实现二分查找时间复杂度O(logN)。加多几层索引快速定位。依旧还是使用空间换时间的方式。
在redis中为什么要使用跳表而不使用红黑树是因为在区间查询时，树的效率没那么高。

1. 它在链表的基础上加了down指针。从一级索引从链的第一个开始往后找。如果在value命中或在value与next的value之间，则判断是否有down指针。
2. 如果有down就往下级索引按照上面的方式查找。如果无down指针则代表已经到最底层了，不在value与next的value区间则代表数据不存在

实现场景:
1.使用链表满足查找时间复杂度O(logN)。



### 树
跳表是通过链表实现，



### 图
跳表是通过链表实现，




---
---
### 数组及链表的对比
选择数组
* 可以申请一块加大的内存空间区域
* 可以通过偏移量快速定位到某个结点的场景
* 无频繁插入/删除的操作，拼接数据除外

选择链表
* 需要频繁插入/删除的操作
* 内存空间有限无法一次性创建一块较大的内存区域
* 需要循环的功能(如双向链表/双向循环链表)

选择跳表(从头开始)————需要考虑新增及删除时，索引是否添加删除的问题
* 在链表的基础上有排序插入/查找的功能(二分查找),时间复杂度O(logN)
* 增加索引层就会带来空间的增加，无需考虑平衡的问题

选择树(从中间开始)————需要考虑树平衡的问题，否则可能会演变O(N)
* 在链表的基础上有排序插入/查找的功能(二分查找),时间复杂度O(logN)
* 增加的空间比跳表的小，对空间有部分要求

---

### 排序
1. O(N²) 冒泡排序、插入排序、选择排序 
   1. 冒泡排序:第一层遍历遍历所有元素，第二层确定右变的位置
      * 每次从第一个元素开始向右对比交换，确保右边一定是比左边大
   2. 插入排序:
      * 111
   3. 选择排序:第一层遍历遍历所有元素，第二层确定左边的位置
      * 引入min指针,遍历右边找出最小的，遍历完就交换,所以能保证左边一定比右边小
2. O(logN): 归并排序、快速排序、计数排序
   1. 归并排序
   2. 快速排序
   3. 计数排序
3. O(N): 基数排序、桶排序 
   1.
   2.

---

### 递归
* 把一个问题分解成可以入栈的子问题
* 存在递归终止的条件(最重要，不然死循环无法退出)
* 抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤系，不要试图用人脑去分解递归的每个步骤
  1.递归函数只想着传参数进来，返回参数出去，用for的思路，提取成一个独立的函数，最重要是需要有终止条件。

需要考虑的问题
1. 递归代码容易堆栈溢出(限制递归深度)
2. 避免环产生

---


















