# 数据结构与算法
数据结构顾名思义就是把一堆数据通过某种方式进行排列起来，其作用是为了快速的查找到想要找到的对象。如果数据是类似于文档的形式往后拼接的话，那么查找一个东西就需要一行行的查找此时查询效率极慢。
所以不同的数据结构对数据查询的时间复杂度是不同的。

数据结构与算法就是不断探索，满足下面的条件:
1. 数据一定有序，如果无序则无法进行对比查询
2. 该数据结构需要从时间复杂度O(N) 尽可能的演变到O(logN)或O(1)
3. 在数据结构中最重要的概念是 "时间换空间" "空间换时间"。


# 基本数据结构
### 数组
开辟一个连续的内存空间，存放相同类型的数据，根据数组起始指针找到其实位置通过offset偏移量乘以每个的长度获取对应的值。由于连续空间CPU的缓存机制，预读数组中的数据，所以访问效率更高
>值 = 开始位置 + 偏移量 * 每个长度

优点:
1. 可以通过偏移量快速找到对应的结点数据,时间复杂度O(1),如果遍历查询依旧是时间复杂度O(N)
2. 无需存放额外的数据字段

缺点：
1. 根据偏移量读取时需要判断避免数组越界
2. 声明时需要定义类型(确定每个的长度用于偏移量获取对应参数) 
3. 新增数据到k的位置时，需要k~n位置的往后挪动，时间复杂度O(N)
    * 当数据不需要有序时把数据放入k中，原先k位置的数据拼接到数组最后，时间复杂度O(1)
4. 删除数据k的位置时，需要k~n位置的往前挪动，时间复杂度O(N)
    * 当数据不需要有序/通过偏移量获取时把数据标记为已删除，等新增填充删除标记的位置，时间复杂度O(1)
5. 需要连续开辟一个连续的内存空间，需要扩容时需要手动处理。同时如果数组过大系统可能没有足够的连续内存空间则会导致内存不足
    * 高级语言中会进行封装一层如 go 的切片。同时扩容也会导致需要申请一个比之前大的内存空间然后进行迁移。性能及内存占用会有一定的开销

实现场景:
快速查找: 可以通过偏移量offset快速定位某个值，长度，二分查找
其他数据结构: 哈希

### 链表
通过零散的内存块串联起来。所以每个结点都应该存放额外的数据(prev指针，next指针)

由链表的形式演变出下面几种
* 单链表: 只有next指针可以找到下一个结点,时间复杂度O(1)
* 双向链表: 有prev指针，next指针可以找到上一个及下一个结点,时间复杂度O(1)
* 单向循环链表: 由于普通的链表最后的指针为null,循环就是需要把最后的next指针指向第一个，形成一个环形
* 双向向循环链表: 与结合双向链表及单向循环链表

优点:
1. 在新增/删除时无需挪动位置后面的数据
2. 在创建时无需提前申请一批内存大小，无需考虑扩容的问题。

缺点:
1. 无法通过偏移量快速找到对应数据
2. 由于连接是通过prev指针及next指针则需要存放额外的数据

实现场景:
LRU: 最近使用的放在链的头，淘汰删除链尾。
其他数据结构: 跳表，树，队列，栈，堆，图等

---


## 数组与链表扩展(栈与队列、hash及跳表)

### 栈
栈是可通过数组(顺序栈)或链表(链式栈)实现。主要的目的是实现先进后出的作用（只允许在一端插入和删除数据。）

1. 入栈: 当栈的空间未满时时间复杂度为O(1),当栈满时时间复杂度为O(N)是因为需要扩容进行搬迁的操作
2. 出栈: 在栈顶剔出时间复杂度为O(1)

实现场景:
1. 操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构,用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返
回之后，将这个函数对应的栈帧出栈
2. 表达式求值: 34+13*9+44-12/3 通过两个栈实现当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比
   较。
3. 括号是否匹配:(1+2)-4+(3-1)



### 队列
队列是可通过数组(顺序栈)或链表(链式栈)实现。主要的目的是实现先进先出的作用

1. 入队: 当栈的空间未满时时间复杂度为O(1),当栈满时可以考虑阻塞或丢弃(阻塞的话用另外一个队列处理)
2. 出对: 在栈顶剔出时间复杂度为O(1)

实现场景:
1. 消息队列(先进先出)


### 哈希
hash是通过数组的方式实现的。通过如hash(data)对数据求一个hash值，然后取模保存到对应的数组偏移位置上。为了满足时间复杂度O(1)。 hash经常用到数组及链表组合实现(链式法)。

hash冲突如何解决:
1. 开放寻址法(不开辟新的空间，往后找空余位置) 对空间有要求，查找会慢一点
   * 线性探测: 往后遍历找到空的地方进行存放(在删除时不能对数据进行删除只能标识，因为查询时hash冲突往后找空的，中间如果被清空就会导致停止认为不存在)
   * 二次探测：往后遍历找到空的地方进行存放(与线性类似只是 hash(data)+1²  hash(data)+1³ ... )
   * 双重散列: 通过hash2，hash3函数再次进行hash找到新的位置
2. 链表法(开辟新的空间) 对空间无要求，查找会更快
   * 新建一个链表的方式进行链式存储，时间复杂度从O(1) 演变为O(链的长度k)

渐进式hash扩容
当数据达到装载因子阈值时(如0.7),此时需要申请一块新的内存(大一倍或多少等),由于避免O(N)的时间复杂度，所以在查询或操作的同时顺便把原先的hash部分迁移到新的hash。在查询时先查询旧的hash，然后再查询新的hash

实现场景:
1. 通过hash快速查找/判断是否存储的数据，时间复杂度O(1)



### 跳表
跳表是通过链表实现，由于链表无法像数组一样通过偏移量查找对应的数据，同时无法判断当前的长度，中间位置是什么，所以通过加索引的方式实现二分查找时间复杂度O(logN)。加多几层索引快速定位。依旧还是使用空间换时间的方式。
在redis中为什么要使用跳表而不使用红黑树是因为在区间查询时，树的效率没那么高。

1. 它在链表的基础上加了down指针。从一级索引从链的第一个开始往后找。如果在value命中或在value与next的value之间，则判断是否有down指针。
2. 如果有down就往下级索引按照上面的方式查找。如果无down指针则代表已经到最底层了，不在value或next的value区间则代表数据不存在

实现场景:
1. 使用链表满足查找时间复杂度O(logN)。



### 树
跳表是通过链表实现，虽然hash的时间复杂度是O(1),但是它是无序的无法找出区间。由于hash是数组就需要考虑扩容的问题性能差。当hash冲突时演变后的数据不一定比O(logN)快。

几个重要概念:
1. 几个节点有相同的父节点称为 "兄弟节点"
2. 没有父节点的称为 "根节点"
3. 没有子节点的称为 "叶子节点"
4. 高度是从下到上(从0开始), 深度是从上到下(从0开始)，层是从上到下(从1开始)
5. 满二叉树是所有的节点都有左右子节点
6. 完全二叉树———除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。为了满足数组的存储方式(根据广度优先遍历)
   * 非完全二叉树，其实会浪费比较多的数组存储空间(要预留空位置给空节点)
7. 二叉查找树又称为二叉排序树(有顺序才能查找得快)
8. 堆是完全二叉树
9. 平衡二叉树(二叉树中任意一个节点的左右子树的高度相差不能大于1)一般用红黑树,因为插入删除的性能更加稳定(近似平衡非严格平衡二叉树)
   * 根节点是黑色的
   * 新插入的节点是红色的
      1. 插入节点的父节点是黑色的则无需处理
      2. 插入的节点是根节点把它变成黑色
      3. 如果插入后不满足相邻的两个个节点不能是红色，那就左旋或右旋————类似魔方的公式
   * 相邻的两个个节点不能是红色 (并不是兄弟节点，而是父子节点相邻)
   * 所有的叶子节点都是黑色的不存储数据 (为了简化代码实现的)
   * 从某个节点到所有叶子结点的路径中，黑色节点点数相同

实现场景:
1. 数据量较大(不能用数组)，有排序查找要求(不能简单的用链表)，可以选择跳表或树(B+树就是解决树区间查询的问题)



### 图
跳表是通过链表实现，

几个重要概念:
1. 元素叫做 "顶点"
2. 一个顶点与其他顶点建立关系叫做 "边" 。 有一种图是边带有权重叫"带权图"用来表示边的权重
3. 与顶点连接的条数叫做 "度"。 指向这个顶点叫"入度", 从这个顶点指向其他的顶点叫"出度"
4. 有带箭头的叫做 "有向图" , 无带箭头的叫做 "无向图"

数据保存方式:
* 领接矩阵: 是一个二维数组，对于无向图来说，顶点i与顶点j有边，则 array【i】【j】 , array【j】【i】  标记为1,无向图则第二个是浪费的。我们存储的是稀疏图，如果微信有好几亿的用户，那么这个图就有好几亿的顶点。但是其实好友关联的不多，就大大浪费了空间
   * 优势： 简单执行效率高。 —— 可以解决最短路径问题
   * 缺点： 浪费较大空间。
* 领接表: 类似hash方式，每个顶点对应是一条链(可以用跳表，树等数据结构)。用时间换空间
   * 优势：节省空间
   * 缺点：执行效率较低，(查找我关注了某些用户非常简单，有哪些用户关注了我就非常困难所以需要逆邻接表) ——关注列表，被关注列表
   * 存储：哈希算法对数据进行分片存储在不同机器上。

---
### 几种数据结构的演变
选择数组
* 可以申请一块加大的内存空间区域
* 可以通过偏移量快速定位到某个结点的场景
* 无频繁插入/删除的操作，拼接数据除外

选择链表
* 需要频繁插入/删除的操作
* 内存空间有限无法一次性创建一块较大的内存区域
* 需要循环的功能(如双向链表/双向循环链表)

选择队列或栈
* 底层可通过数组或链表进行实现。主要根据实际场景先进先出还是先进后出

选择跳表(从头开始)————需要考虑新增及删除时，索引是否添加删除的问题
* 在链表的基础上有排序插入/查找的功能(二分查找),时间复杂度O(logN)
* 增加索引层就会带来空间的增加，无需考虑平衡的问题

选择树(从中间开始)————需要考虑树平衡的问题，否则可能会演变O(N)
* 在链表的基础上有排序插入/查找的功能(二分查找),时间复杂度O(logN)
* 增加的空间比跳表的小，对空间有部分要求

选择图
* 需要特殊的使用场景才会用到图。


---

### 排序
排序需要考虑以下: 
1. 时间复杂度
2. 原地排序算法: 空间复杂度是O(1)
3. 稳定性: 两个相同的值不能发生位置改变


* O(N²) 冒泡排序、插入排序、选择排序 
   1. 冒泡排序:第一层遍历所有元素，第二层确定右变的位置
      * 每次从第一个元素开始向右对比交换，确保右边一定是比左边大
   2. 插入排序: 第一层从第二个遍历所有元素，第二层确定左边的位置
      * 向左遍历找出比他自己小的，依次向右挪动位置，
   3. 选择排序:第一层遍历所有元素，第二层确定左边的位置
      * 引入min指针,遍历右边找出最小的，遍历完就交换,所以能保证左边一定比右边小

* O(logN): 归并排序、快速排序 ———— 适用与数据量较大的数据
   1. 归并排序: 数组从中间分成前后两部分，然后对前后两部分分别排序
      * 采用递归的方式如果数组个数等于1个返回。否则继续二分递归。把二分递归的结果merge
   2. 快速排序: 选择p到r之间的任意一个数据作为pivot（分区点）将小于pivot的放到左边，将大于pivot的放到右边，将pivot放到中间

* O(N): 基数排序、桶排序 、计数排序 ———— 不基于比较的
   1. 桶排序:  用数组实现，每一个区间值为一个桶，把对应的值放入桶中（有些桶是空的）
   2. 计数排序: 用数组实现，每一个数值值为一个桶，把对应的值放入桶中（有些桶是空的）
   3. 基数排序: ，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果a数据的高位比b数据大，那剩下的低位就不用比较了
---

### 递归
* 把一个问题分解成可以入栈的子问题
* 存在递归终止的条件(最重要，不然死循环无法退出)
* 抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤系，不要试图用人脑去分解递归的每个步骤
  1.递归函数只想着传参数进来，返回参数出去，用for的思路，提取成一个独立的函数，最重要是需要有终止条件。

需要考虑的问题
1. 递归代码容易堆栈溢出(限制递归深度)
2. 避免环产生

---

### 字符串匹配算法
1. 主串: 就是字符串A
2. 模式串: 就是字符串B
>在字符串A中查找字符串B

BF及PK算法：RK是BF的改进版
   * BF: 暴力算法,拿模式串与主串的位置一对比，匹配不上与主串的位置二对比... ,主串跟模式串中每个byte进行对比(这里是O(m))。  时间复杂度O(n*m)
   * RK: 拿模式串与主串的位置一对比,匹配不上与主串的位置二对比... ,与截取主串的数据进行hash或生成字符串匹配(这里是O(1))。  时间复杂度O(n)
BM及KMP算法：
   * BM: 高效/常用的匹配算法(编辑器查找替换功能),减小匹配的次数,主要的优化点有以下
     1. 在匹配的过程中是从后往前的
     2. 匹配的过程中如果发现主串的的值在模式串中不存在，就可以直接往前挪动几位(坏字符规则)
     3. 匹配的过程中如果发现主串的的值在模式串中存在，一个个挪也有点慢，找出模式串的子串，对比主串就可以往前挪动几位(好后缀)
   * KMP: 最知名的匹配算法
     1. 
      
Trie树及AC自动机：
   * Trie树
   * AC自动机
   
---

### 算法思想
1. 贪心算法: 在满足限制值的情况下，期望值最大。(贪心算法的解决思路是，每次都选择一条跟当前顶点相连的权最小的边，直到找到顶点T。但不是最优)
2. 分治算法: 将原问题划分成n个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解
3. 回溯算法: 一直通过回溯的方法找出最优解（遍历所有的，找出最优）
4. 动态规划: 有几种方案找出最优的方法

---

排序（快排）
堆
红黑树下
广度优先 ，深度优先算法
BM及KMP trie树 ac自动机

贪心算法：
分糖果：   需求小的孩子开始分配糖果。因为满足一个需求大的孩子跟满足一个需求小的孩子，对我们期望值的贡献是一样的。我们每次从剩下的孩子中，找出对糖果大小需求最小的
钱币找零： 我们希望贡献多的点金额(即金额大的)————尽可能还完钱，使用的纸币最少
区间覆盖： 


分治算法：
二维平面上有n个点，如何快速计算出两个距离最近的点对？
有两个n*n的矩阵A，B，如何快速求解两个矩阵的乘积C=A*B？


回溯算法: 
0-1背包：  
正则表达式















