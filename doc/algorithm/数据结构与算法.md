# 线性结构
## 数组与链表

### 数组
开辟一个连续的内存空间，存放相同类型的数据，根据数组起始指针找到其实位置通过offset偏移量乘以每个的长度获取对应的值。由于连续空间CPU的缓存机制，预读数组中的数据，所以访问效率更高
>值 = 开始位置 + 偏移量 * 每个长度

优点:
1. 可以通过偏移量快速找到对应的结点数据,时间复杂度O(1),如果遍历查询依旧是时间复杂度O(n)
2. 无需存放额外的数据字段

缺点：
1. 根据偏移量读取时需要判断避免数组越界
2. 声明时需要定义类型(确定每个的长度用于偏移量获取对应参数) 
3. 新增数据到k的位置时，需要k~n位置的往后挪动，时间复杂度O(n)
    * 当数据不需要有序时把数据放入k中，原先k位置的数据拼接到数组最后，时间复杂度O(1)
4. 删除数据k的位置时，需要k~n位置的往前挪动，时间复杂度O(n)
    * 当数据不需要有序/通过偏移量获取时把数据标记为已删除，等新增填充删除标记的位置，时间复杂度O(1)
5. 需要连续开辟一个连续的内存空间，需要扩容时需要手动处理。同时如果数组过大系统可能没有足够的连续内存空间则会导致内存不足
    * 高级语言中会进行封装一层如 go 的切片。同时扩容也会导致需要申请一个比之前大的内存空间然后进行迁移。性能及内存占用会有一定的开销

---

### 链表
通过零散的内存块串联起来。所以每个结点都应该存放额外的数据(prev指针，next指针)

由链表的形式演变出下面几种
* 单链表: 只有next指针可以找到下一个结点,时间复杂度O(1)
* 双向链表: 有prev指针，next指针可以找到上一个及下一个结点,时间复杂度O(1)
* 单向循环链表: 由于普通的链表最后的指针为null,循环就是需要把最后的next指针指向第一个，形成一个环形
* 双向向循环链表: 与结合双向链表及单向循环链表

优点:
1. 在新增/删除时无需挪动位置后面的数据
2. 在创建时无需提前申请一批内存大小，无需考虑扩容的问题。

缺点:
1. 无法通过偏移量快速找到对应数据
2. 由于连接是通过prev指针及next指针则需要存放额外的数据

实现场景:
LRU: 最近使用的放在链的头，淘汰删除链尾。

---

### 数组及链表的对比
选择数组
* 可以申请一块加大的内存空间区域
* 可以通过偏移量快速定位到某个结点的场景
* 无频繁插入/删除的操作，拼接数据除外

选择链表
* 需要频繁插入/删除的操作
* 内存空间有限无法一次性创建一块较大的内存区域
* 需要循环的功能(如双向链表/双向循环链表)

选择树
* 在链表的基础上有排序插入/查找的功能(二分查找),时间复杂度O(logN)

---

## 数组与链表扩展(栈与队列)

### 栈
栈是可通过数组(顺序栈)或链表(链式栈)实现。主要的目的是实现先进后出的作用（只允许在一端插入和删除数据。）

1. 入栈: 当栈的空间未满时时间复杂度为O(1),当栈满时时间复杂度为O(n)是因为需要扩容进行搬迁的操作
2. 出栈: 在栈顶剔出时间复杂度为O(1)

实现场景:
1. 操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构,用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返
回之后，将这个函数对应的栈帧出栈
2. 表达式求值: 34+13*9+44-12/3 通过两个栈实现当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比
   较。
3. 括号是否匹配:

---

### 队列
队列是可通过数组(顺序栈)或链表(链式栈)实现。主要的目的是实现先进先出的作用

1. 入队: 当栈的空间未满时时间复杂度为O(1),当栈满时可以考虑阻塞或丢弃(阻塞的话用另外一个队列处理)
2. 出对: 在栈顶剔出时间复杂度为O(1)

实现场景:
1. 操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构,用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返
   回之后，将这个函数对应的栈帧出栈
2. 表达式求值: 34+13*9+44-12/3 通过两个栈实现当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比
   较。
3. 括号是否匹配:

---

### 递归
* 把一个问题分解成可以入栈的子问题
* 存在递归终止的条件(最重要，不然死循环无法退出)
* 抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤系，不要试图用人脑去分解递归的每个步骤
  1.递归函数只想着传参数进来，返回参数出去，用for的思路，提取成一个独立的函数，最重要是需要有终止条件。

需要考虑的问题
1. 递归代码容易堆栈溢出(限制递归深度)
2. 避免环产生

---

### 排序
* 冒泡排序、插入排序、选择排序 O(N²)
1. 冒泡排序:第一层遍历遍历所有元素，第二层确定右变的位置
   * 每次从第一个元素开始向右对比交换，确保右边一定是比左边大
2. 插入排序:
   * 111
3. 选择排序:第一层遍历遍历所有元素，第二层确定左边的位置
   * 引入min指针,遍历右边找出最小的，遍历完就交换,所以能保证左边一定比右边小


* 归并排序、快速排序、计数排序 O(logN)
1. 归并排序
2. 快速排序
3. 计数排序
* 基数排序、桶排序 O(n)

比较排序算法:
1. 比较
2. 交换

---
# 非线性结构
### 树

### 图














