微服务的驱动力
    性能不会因为微服务而凭空消失，拆成多个微服务，一旦某个地方卡住，那么往往还不如单体应用
    硬件的成本能够持续稳定的下降，而软件开发的成本不可能。
    
    选择微服务通常比较常见、合理的驱动力来自组织的内部外部两方面
    外部：
        1.每个语言都有不同的优势，很多时候需要异构能力进行分布式部署，不是你想不想的问题，而是没有选择，无法避免
            java服务，python人工智能，并发go
        2.个人能力因素
            系统的质量只能依靠研发和项目管理，微服务可作为专家掌控架构约束力
                让高水平的开发，运维去保证关键技术和业务服务可靠
                其他外围的功能即使不靠谱也不会影响到系统的稳定性及局部的容错性
        3.外部商业层面对内部技术提出的要求
            甲方的招标文件要求必须用微服务
    内部：
        1.变化发展特别快的创新业务系统
            快速迭代，让代码避免在类库直接依赖而导致纠错不清
        2.大规模复杂的系统

------------
微服务需要的条件
    1.意识到康威定律在软件总的关键作用
        “沟通决定设计”（跨技术，跨组织，跨功能 就应该分开）
            如果技术层面紧密联系在一起特性，在组织层面上强行分离，结果会是沟通成本的上升，产生大量跨组织沟通
            如果技术层面没有什么联系，组织层面强行放在一块，结果会管理成本的上升，成员越多越不利一致决策
    2.对微服务需要有充分的理解，有一定的时间经验
        对架构能力要求已提升到史无前例的程度。
    3.应以自治为目标的自动化与监控能力
        微服务大量松耦合，将自动化和监控读量为他们建设的前提
            1.环境预置。需要在短时间启动一台新的服务器
            2.基础监控。出现什么问题可以快速捕捉
            3.快速部署。让服务的变更迅速部署在测试、生产环境
    4.复杂性成为制约生产力的主要矛盾
        项目越来越难维护
          

    为什么要拆：
        1.如果跨部门，跨技术等沟通起来麻烦就应该考虑拆
        2.复杂性应该影响到生产力就应该考虑拆

    要做这件事需要具备：
        1.需要对微服务有重复的理解（对架构要求能力高）
        2.需要有一系列自增能力和监控能力

----------
微服务的边界
    领域驱动设计DDD
        涉及抽象业务，分析流程，识别边界，建立模型，映射到服务和代码等偏理论
    
    微服务的设计
        不可能每个人设计的力度相同，微服务的大小，边界不应该只有唯一的答案或绝对的标准
        微服务的边界应该满足
            能独立发布，独立部署，独立运行，独立测试
            内聚、强相关的应该放在同一个服务
            完备一个服务包含至少一项业务实体和对应操作

        微服务不是尽可能的设计小
            1.性能。进程内的调用（一次跨服务的调用涉及到网络传输，序列化，反序列化等耗时可到毫秒级别。）
            2.数据一致性。每个微服务都有独立的数据源，多个微服务同时协同工作，就要考虑处理数据最终一致性
                某些数据要求强一致性的话，xa事务的可用性会越来越差
            3.可用性角度。如果两个服务必须互相依赖才能工作，重启，故障会导致中断
                那么应该合到一个微服务

        微服务也不能设计太大
            1.太大会退化成单体服务
            2.开发中沟通成本加大
----------
系统的复杂性
    治理：让产品可以保持符合预期的稳定运行。（1.正确稳定执行，2持续保持）

    静态的治理
        1.认知负荷。表现为接收业务，概念，代码等信息带来的负担大小。系统个体的认知负担越大，系统就越复杂。
            技术的进步跟诞生。导致不可能全部掌控

        2.协作成本。表现为团队共同研发付出的沟通，管理成本。系统个体的协作成本越高，系统就越复杂。
            微服务的交互分为服务内部调用，和进程内调用
            组织的沟通也分为内部沟通和团队之间沟通。

    发展的治理
        ”架构腐化“ 只能延缓，无法避免
            随着时间的变化，团队对该项目的质量保持能力会逐渐下降，在迭代过程中会代码会不停变化。

    
    大型的软件演进是一个不断推倒重来的演进过程，前一个版本对后一个版本的价值在于他满足了这个阶段的需要。
    

