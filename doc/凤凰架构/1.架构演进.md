架构不是“发明”出来的，是演进的结果

由于当时单机计算能力很差，看能不能用多台电脑协同工作，但是调用远程方法困难导致了无法实现——————第一次（但也是之后提供了很多思想）
计算机的发展提高了算力（摩尔定律），用单台计算机就能支持大型的系统的运作，单体服务在此盛行————第二次（硬件赶得上软件的发展）
计算机的发展开始变得缓慢，单台计算机满足不了当前的需求,结合目前的技术，微服务开始重新找回—————第三次（硬件赶不上需求的发展）


原始分布式时代”一节中 Unix DCE 提出的分布式服务的设计主旨：“让开发人员不必关心服务是远程还是本地，都能够透明地调用服务或者访问资源”。经过了三十年的技术进步，信息系统经历了巨石、烟囱、插件、事件、SOA 等的架构模式，应用受架构复杂度的牵绊却是越来越大，已经距离“透明”二字越来越远了，这是否算不自觉间忘记掉了当年的初心？接下来我们所谈论的微服务时代，似乎正是带着这样的自省式的问句而开启的。

对于架构演进的未来发展，2014 年，Martin Fowler 与 James Lewis 在《Microservices》的结束语中曾写到，他们对于微服务日后能否被大范围地推广，最多只能持有谨慎的乐观，在无服务方兴未艾的今天，与那时微服务的情况十分相近，笔者对无服务日后的推广同样持谨慎乐观的态度。软件开发的最大挑战就在于只能在不完备的信息下决定当前要处理的问题。时至今日，依然很难预想在架构演进之路的前方，微服务和无服务之后还会出现何种形式的架构风格，但这也契合了图灵的那句名言：尽管目光所及之处，只是不远的前方，即使如此，依然可以看到那里有许多值得去完成的工作在等待我们。





##单体
规模小应该毫不犹豫的使用单体服务，任何项目不可能都成长为大规模，前期使用单体架构是一个非常明确的选择
演进到规模大后变大劣势，这个时候才要考虑微服务————（部分功能重启，进程独立，人员过大进行拆分，单机性能满足不了软件需求）
单体的难度不在于如何拆分，而是拆分后的隔离和自治力的缺陷

    1.编译/打包慢——多个人同时开发，多次编译，时间慢，验证慢
    2.上线启动慢
    3.项目不好管理（我能改你的，你能改我的）
    4.沟通成本大
    5.同个进程，一个东西有问题会影响整个服务
    
    
    1.便于调试，部署，测试
    2.开发效率快，执行效率快




优势：
    易于开发，易于测试，易于部署
    运行同一个进程空间内，模块方法的调用无需考虑网络分区，无需考虑对象复制这些麻烦的事，获取进程调用的简单高效等好处
劣势：
    但如果一部分代码缺陷，过度占用进程空间资源，所造成的影响是全局性的。无法起到隔离，
    也就无法停止某一部分代码，重启一部分程序

进退两难（需要突破但是为能找到突破点）
    1.规模大时需要维护部署的成本加大，
    2.单体难以阻断错误传播，不便于动态更新程序，还面临异构的困难。




##SOA （有中心化（服务总线）的各个服务）
    SOA解决单体架构的解决方案，提出许多概念、思想都已经能在今天微服务中找到对应的身影了。。
        譬如服务之间的松散耦合、注册、发现、治理，隔离、编排，等等。这些在今天微服务中耳熟能详的名词概念，
    为什么得不到发展：
        过于严格的规范定义带来过度的复杂性。
            而构建在 SOAP 基础之上的 ESB、BPM、SCA、SDO 等诸多上层建筑，进一步加剧了这种复杂性。




##微服务 （去中心化的各个服务）
    服务可以说是 SOA 发展时催生的产物。
    微服务是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。
    各个服务可以采用不同的编程语言，不同的数据存储技术，运行在不同的进程之中。
    服务采取轻量级的通信机制和自动化的部署机制实现通信与运维。  
    *   1.多个小型服务构建单个应用的架构风格
        2.可以采用不用的编程语言及不同存储技术
        3.轻量级通讯及自动化部署

    微服务追求的是更加自由的架构风格，摒弃了几乎所有 SOA 里可以抛弃的约束和规定，提倡以“实践标准”代替“规范标准”
        微服务所带来的自由是一把双刃开锋的宝剑，当软件架构者拿起这把宝剑，
        SOA 定下的复杂技术标准，将选择的权力夺回的同一时刻，
        
    微服务时代中，软件研发本身的复杂度应该说是有所降低。一个简单服务，并不见得就会同时面临分布式中所有的问题，也就没有必要背上 SOA 那百宝袋般沉重的技术包袱。需要解决什么问题，就引入什么工具；团队熟悉什么技术，就使用什么框架。
        作为一个普通的服务开发者，作为一个“螺丝钉”式的程序员，微服务架构是友善的。
        作为一个架构者是满满的恶意，对架构能力要求已提升到史无前例的程度，

技术架构者的第一职责就是做决策权衡，有利有弊才需要决策，有取有舍才需要权衡，如果架构者本身的知识面不足以覆盖所需要决策的内容，不清楚其中利弊，恐怕也就无可避免地陷入选择困难症的困境之中。




##后微服务——云原生 
    基础功能由基础设施处理
    注册发现、跟踪治理、负载均衡、传输通讯等一定要分布式系统自己解决吗
    之所以微服务时代，人们选择在软件的代码层面而不是硬件的基础设施层面去解决这些分布式问题，
    很大程度上是因为由硬件构成的基础设施，跟不上由软件构成的应用服务的“灵活性”的无奈之举。

        如果某个系统需要伸缩扩容，通常会购买新的服务器，部署若干副本实例来分担压力；
        如果某个系统需要解决负载问题，通常会布置负载均衡器，选择恰当的均衡算法来分流；
        如果需要解决传输安全问题，通常会布置 TLS 传输链路，配置好 CA 证书以保证通信不被窃听篡改；
        如果需要解决服务发现问题，通常会设置 DNS 服务器，让服务访问依赖稳定的记录名而不是易变的 IP 地址，
        
    注册发现、跟踪治理等等问题的解决，依靠的就是虚拟化技术和容器化技术
    当虚拟化的基础设施从单个服务的容器扩展至由多个容器构成的服务集群、通信网络和存储设施时，软件与硬件的界限便已经模糊。
        一旦虚拟化的硬件能够跟上软件的灵活性，那些与业务无关的技术性问题便有可能从软件层面剥离，
        悄无声息地解决于硬件基础设施之内，让软件得以只专注业务，真正“围绕业务能力构建”团队与产品。

    从软件层面独力应对分布式架构所带来的各种问题，发展到应用代码与基础设施软、硬一体，合力应对架构问题的时代，现在常被媒体冠以“云原生”这个颇为抽象的名字加以宣传。云原生时代与此前微服务时代中追求的目标并没有本质改变，在服务架构演进的历史进程中，笔者更愿意称其为“后微服务时代”。




##服务网格（Service Mesh）的“边车代理模式”（Sidecar Proxy），
    所谓的“边车”是一种带垮斗的三轮摩托，我小时候还算常见，现在基本就只在影视剧中才会看到了。这个场景里指的具体含义是由系统自动在服务容器（通常是指 Kubernetes 的 Pod）中注入一个通信代理服务器，相当于那个挎斗，以类似网络安全里中间人攻击的方式进行流量劫持，在应用毫无感知的情况下，悄然接管应用所有对外通信。这个代理除了实现正常的服务间通信外（称为数据平面通信），还接收来自控制器的指令（称为控制平面通信），根据控制平面中的配置，对数据平面通信的内容进行分析处理，以实现熔断、认证、度量、监控、负载均衡等各种附加功能。这样便实现了既不需要在应用层面加入额外的处理代码，也提供了几乎不亚于程序代码的精细管理能力。




##无服务架构
    无服务架构对一些适合的应用确实能够降低开发和运维环节的成本，譬如不需要交互的离线大规模计算，又譬如多数 Web 资讯类网站、小程序、公共 API 服务、移动应用服务端等都契合于无服务架构所擅长的短链接、无状态、适合事件驱动的交互形式；但另一方面，对于那些信息管理系统、网络游戏等应用，又或者说所有具有业务逻辑复杂，依赖服务端状态，响应速度要求较高，需要长链接等这些特征的应用，至少目前是相对并不适合的。


---------------
RPC远程服务调用
    为了让计算机能够跟调用本地一样去调用远程方法。

    其他方式：  
    管道（有亲缘关系的进程通讯）、具名管道（无亲缘关系的进程通讯）
        类似于两个进程间的桥梁，可通过管道在进程间进行传递少了的字节流，普通的管道只能用在有亲缘关系（父/子进程）进程间的通信
            具名管道摆脱普通没有名字的现状，还运行无亲缘关系进程间的通信，管道类型的应用就是命令行中的"|"操作符
            将 ps 命令的标准输出通过管道，连接到 grep 命令的标准输入上
            ‘’‘
            ps -ef | grep java  (ps查看进程，grep 在内容中进行筛选)
            ’‘’
    信号
        用于通知目标进程有某种事件发生，除了进程间通信外，进程还可以发送信号给进程自身
            ‘’‘
            kill -9 pid
            ‘’‘
    信号量
        用于两个进程之间同步协作手段，相当于操作系统提供一个特殊遍历，程序可以在上面进行wait和notify操作
    消息队列
        以上只能传输少量信息，在posix标准定义了消息队列用于进程间数据量较多的通信，但实时性相对受限（我认为是单向）
    共享内存
        允许多个进程访问同一个内存空间，效率最高的形式
    套接字**
        以上都是适合单机多进程，套接字接口更适合不同机器的的通信。当在本机进行通信时，套接字被优化过，无需打包拆包，计算校验，维护序号和应答操作。
    
通信的成本
    在socket上与远程调用与本地通信上的编码完全一致，让程序员认为“通信是无成本的假象”。从而被滥用以至于减低分布式系统的性能
        但事实上socket并没有那么可靠
        
    RPC是一种语言级别的通讯协议，socket底层级别的通讯协议
    刚开始没有流行的原因是只能传递值而不支持对象，近几年不止解决三个问题（表示数据，数据传递，表示方法），还将一部分功能设置成扩展点，让用户选择：如负载均衡，服务注册，可观察性等
    
        表示数据——请求/相应的定义用于如何序列号
        数据传递——tcp连接，超时，安全，事务，交互数据
        表示方法——IDL (interface Description Language)
    
    
    
   
       



REST
    REST并不是一种远程服务调用协议.REST只能说是风格而不是规范、协议。REST的基本思想是面向资源来抽象问题
    完全满足 REST 风格的系统应该满足以下六大原则。
        1.服务端与客户端分离（Client-Server）即前后端分离不再是通过渲染的方式
        2.无状态 即每个接口不保存上下文等状态，只通过数据的传递进行处理
        3.可缓存 即提高了性能
        4.分层系统 客户端一般不会直接连接最终服务器，通过负载和缓存提高系统扩张性。
        5.统一接口 希望面向资源编程，而不是抽象系统该有那些行为。（通过get post delete等方式对接口进行满足）
            对该商品进行相关的请求（get获取商品信息，post新增商品信息，put修改商品信息，delete删除商品信息）


    REST与http完全绑定，不适合高性能的场景
    REST不支持事务
    返回时无法想RPC一样规定了有什么参数，什么类型  
    


    
