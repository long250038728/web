事务ACID
原子性：Atomic
一致性：Consistency
隔离性：Isolation
持久性：Durabitity

A、I、D是手段，C是目的

事务的起源是数据库系统，现在已经不局限于数据库本身。所有保证数据一致性的应用场景
    如数据库，事务内存，缓存，消息队列，分布式缓存等待

    内部一致性：（使用一个数据源，如只使用数据库）
        一个服务使用一个数据源，通过A、I、D来获取一致性是最经典的做法，多个并发事务所读写的数据能够被数据源感知是否冲突，并发事务的读写在时间上是最终顺序是由数据源决定的
    外部一致性：(一个服务多个数据源，一个服务多个数据库)
        一个服务使用多个数据源，甚至多个服务使用不同的数据源。问题就变得困难许多。并发甚至是先后执行的多个事务，时间上的顺序并不由一个数据源来决定。（分布式系统中必定会遇到且必须解决的，将一致性“是否”转变为可以按不同强度分开讨论的多元属性，确保代价可承受的前提获得更高一致性保障）
            “编程问题” =》 “架构问题”


数据源指的是提供数据的逻辑设备，不必与物理设备一一对应，在部署应用集群时最常见的模式用一套存现部署到多个中间件服务器上，构成多个副本实例来分担集群压力，虽然连接时一个数据库，但是每个节点都有自己的专属资源。每个节点使用的仍是最简单的本地事务。

-------------

本地事务：
    本地事务最基础的事务解决方案，它是直接依赖数据源本身提供的事务能力来工作，在程序代码层面最多只能对事务接口做一层标准化的包装，并不能深入参与事务运行过程中，如事务开启，回退，提交，设置隔离级别。

原子性及持久性
    原子性保证了事务的多个操作要么都生效要么都不生效，不会存在中间状态；
    持久性保证了一旦事务生效，就不会再因为任何原因而导致其修改的内容被撤销或丢失。

 以日志的形式——即仅进行顺序追加的文件写入的形式（这是最高效的写入方式）先记录到磁盘中。
    force：在事务提交后，变动的数据必须同时完成写入force，如果不强制变动数据必须同时完成则称为no-force。
            现实中有太多数据库采用no-force。因为只有日志，变动数据可以随时持久化。从优化磁盘i/o角度上，没有必要强制数据库写入理解进行。
    steal：在事务提交前，允许变动数据提前写入steal。不允许则为no-steal，
            从优化磁盘i/o角度上，允许数据提前写入，有利于空闲i/o资源

    Commit Logging：（提交日志）
        只有在日志记录全部都安全落盘，数据库在日志中看到代表事务成功提交的“提交记录”（Commit Record），
            后才会根据日志上的信息对真正的数据进行修改，修改完成后，
        再在日志中加入一条“结束记录”（End Record）表示事务已完成持久化
            1.处理、写日志、处理、写日志
            2.事务提交的“提交记录”（Commit Record）
            2.事务持久化的“结束记录”（End Record）
        缺陷：
            在所有数据的真实修改都应该在事务提交之后，即日志写入Commit Record后。（对性能十分不利）

    Write-Ahead Logging：(提前写入)
        允许在事务提交前，写入变动数据

    Commit Logging：允许no-force（事务提交后写入）。但不允许steal（事务提交前写入）。
            因为事务提交前部分变动写入磁盘，那一旦事务回滚会发送奔溃，提交前写入的变动数据就成了错误
    Write-Ahead Logging：允许no-force（事务提交后不写入）也与允许steal（事务提交前写入）。
            给出的解决办法是新增了undo log 日志类型，
                在变动数据写入磁盘前，必须先记录undo log。注明修改哪个位置的数据，什么值修改为什么值，以便在事务回滚根据undo log 对提前写入的数据变动进行擦除。
                此前记录用于奔溃时重演数据变动的日志命名为redo log，

    Write-Ahead Logging奔溃恢复有三个阶段：
        分析阶段：
            从检查最后一次checkpoint(最后持久化的点)，开始扫描日志，end record事务（包括Commit Record和未Commit Record）。组成待恢复的事务集合。
        重做阶段：
            分析阶段中产生待恢复事务集合重演历史，找出所有包含commit record日志。把这些日志修改写入磁盘，
        回滚阶段：
            在分析，重做阶段剩余的恢复集合，把此时剩下的就需要回滚事务，他们称谓loser，根据undo log中的信息，将依据提前写入磁盘的信息改回来
            
        通过checkpoint找出需要提交事务跟回滚事务的待处理事务（重做阶段跟回滚阶段阶段都是幂等）
            通过redo log 日志进行重做（找出commit record日志，然后写入到磁盘）
            通过undo log 日志进行回滚（把提前写入磁盘的信息重新修改写回去）


隔离性
    保证每个事务各自读，写的数据互相独立

        锁：在并发中实现串行的数据访问通过锁的方式处理
        写锁（排它锁）：
            如果有数据加写锁，只有持有写锁的人才能写入操作，其他事务不能写入数据，不能加读锁
        读锁（共享锁）：
            多个事务同时对同一个数据加多个读锁，数据被加上读锁后不能加上写锁，但仍可以读，
                如果该数据只有自己一个事务加了读锁，是允许直接加上写锁，
                如果有多个事务加了读锁，则需要等到其他读锁释放后才能加写锁
        范围锁：
            对某个范围加上排它锁，这个范围都不能写入  


        多版本并发控制MVVC：(针对的是读)
            是读取优化策略，他的“无锁”是指读取时不需要加锁，
                mvvc的基本思想是对数据库的任何修改都不会直接覆盖之前的数据，而是产生一个新版本跟老版本共存,以到达读取时不需要加锁的目的
            数据库每一行记录都存在两个看不到的字段，CREATE_VERSION和DELETE_VERSION,这两个字段记录的都是事务id，
                新增时，CREATE_VERSION记录插入事务的id
                删除时，DELETE_VERSION记录删除事务的id
                修改数据时，视为“删除旧数据，插入新数据”的组合，
                    把原先数据复制一份，原有的数据DELETE_VERSION为修改事务id
                    复制出来新的CREATE_VERSION位修改事务id
            
            可重复读：
                总是读取CREATE_VERSION小于或等于当前事务id的记录，
                (据如果存在多个版本，则读取最新的，类似
                    select * from xxx 
                        where  CREATE_VERSION <= xxxxx
                        GROUP BY id ORDER 
                        BY CREATE_VERSION DESC 
                        LIMIT 1
                ）
            读提交：
                总是读取最新版本即可

---------------

全局事务：
    被限定为一种适用于单个服务使用多个数据源场景的事务解决方案(多个数据库)
    为了解决分布式事务一致性问题，提成了（XA）处理事务的架构，其核心是定义了全局事务管理器，和局部资源管理器之间的通讯，
        XA接口是双向的，能在一个事务管理器和多个资源管理器之间形成通讯桥梁。通过协调多个数据源的一致东站，实现全局事务的统一提交或统一回滚
        
        两阶段提交
        准备阶段：
            协调组循环事务的所有参与者是否准备提交，如果参与者准备好回复prepared，否则回复Non-prepared，准备操作是在重做日志记录中记录全部事务提交操作所要做的内容，它与本地事务真正提交的区别只是不写入最后的Commit record 而已。意味着做完数据持久化不立即释放隔离性。即仍然有锁，维持数据对非其他事务内观察者的隔离状态。
        提交阶段：
            协调组如果在上一个阶段收到所有参与者回复prepared，则自己再本地持久化事务状态为commit，在此操作完成后想所有参与者发送commit命令
            所有参与者执行提交操作，（如一个参与者回复non-prepared或一个参与者未回复，协调者把自己的事务持久化为abrot之后，向所有制发送abrot指令，参与者执行回滚操作）

        三阶段提交
        把准备阶段分为canCommit，preCommit，把提交阶段doCommit
            canCommit增加了一个询问阶段，协调组让每个参与的数据库根据自身状态，苹果事务能否顺利完成。将准备阶段分为两个的理由是这个阶段是重负载的操作，一旦协调者发出准备的消息，每个参与者都将马上开始写重做日子，他们涉及的数据资源即被锁住，如果此时某个参与者无法提交，相当于大家都白做了一轮无用功能，减少某个参与者提交时发送崩溃而导致大家全部回滚的风险变小

---------------

共享事务：
    与全局事务讨论的单个服务多个数据源正好相反。共享事务指多个服务共用一个数据源。
    理论：
         假设用户，商家及商品仓库都与同一个数据库，只是三个领域部署到独立的微服务。让各个服务共享数据库连接。，在同一个应用进程不同持久化工具中共享数据库连接并不难，但是这共享的前提是数据源的使用者都在同一进程内，由于数据库连接的基础是网络连接，他的ip与端口号绑定，为了实现共享事务，就务必正价一个“交易服务器”中间角色。各个微服务都同一台教育服务器来跟数据库打交道。
    实际：
        与实际生产系统中的压力方向悖论，一个集群服务器里数据库才是压力最大又不好伸缩的重灾区。几乎没有代理一个数据库为多个应用提供事务协调的交易服务代理。
        

-----------------

分布式事务
    指多个服务同时访问多个数据源的事务处理机制

CAP与ACID

CAP 定义一个分布式系统，涉及到共享数据的，三个特性最多同时满足两个
一致性:Consistency   在任何时刻，分布式节点中看到符合预期。
可用性:Availability    分为可靠性（平均无故障时间）及可维护性（可修复时间）
分区容忍性:partition tolerance  部分节点因网络而彼此失联后，与其他节点形成的”网络分区“时，系统仍然可以正常提供服务


如果放弃分区容忍性（CA without P），意味着我们将假设节点之间通信永远是可靠的。永远可靠的通信在分布式系统中必定不成立的，这不是你想不想的问题，而是只要用到网络来共享数据，分区现象就会始终存在。在现实中，最容易找到放弃分区容忍性的例子便是传统的关系数据库集群，这样的集群虽然依然采用由网络连接的多个节点来协同工作，但数据却不是通过网络来实现共享的。以 Oracle 的 RAC 集群为例，它的每一个节点均有自己独立的 SGA、重做日志、回滚日志等部件，但各个节点是通过共享存储中的同一份数据文件和控制文件来获取数据的，通过共享磁盘的方式来避免出现网络分区。因而 Oracle RAC 虽然也是由多个实例组成的数据库，但它并不能称作是分布式数据库。

如果放弃可用性（CP without A），意味着我们将假设一旦网络发生分区，节点之间的信息同步时间可以无限制地延长，此时，问题相当于退化到前面“全局事务”中讨论的一个系统使用多个数据源的场景之中，我们可以通过 2PC/3PC 等手段，同时获得分区容忍性和一致性。在现实中，选择放弃可用性的 CP 系统情况一般用于对数据质量要求很高的场合中，除了 DTP 模型的分布式数据库事务外，著名的 HBase 也是属于 CP 系统，以 HBase 集群为例，假如某个 RegionServer 宕机了，这个 RegionServer 持有的所有键值范围都将离线，直到数据恢复过程完成为止，这个过程要消耗的时间是无法预先估计的。

如果放弃一致性（AP without C），意味着我们将假设一旦发生分区，节点之间所提供的数据可能不一致。选择放弃一致性的 AP 系统目前是设计分布式系统的主流选择，因为 P 是分布式网络的天然属性，你再不想要也无法丢弃；而 A 通常是建设分布式的目的，如果可用性随着节点数量增加反而降低的话，很多分布式系统可能就失去了存在的价值，除非银行、证券这些涉及金钱交易的服务，宁可中断也不能出错，否则多数系统是不能容忍节点越多可用性反而越低的。目前大多数 NoSQL 库和支持分布式的缓存框架都是 AP 系统，以 Redis 集群为例，如果某个 Redis 节点出现网络分区，那仍不妨碍各个节点以自己本地存储的数据对外提供缓存服务，但这时有可能出现请求分配到不同节点时返回给客户端的是不一致的数据。



    “选择放弃一致性的 AP 系统目前是设计分布式系统的主流选择”这个结论感到一丝无奈，
        本章讨论的话题“事务”原本的目的就是获得“一致性”，而在分布式环境中，“一致性”却不得不成为通常被牺牲、被放弃的那一项属性。
        我们建设信息系统，终究还是要确保操作结果至少在最终交付的时候是正确的，（允许数据在中间过程（不一致），但应该在输出时被修正过来）。


    强一致性（Strong Consistency）：
        将前面我们在 CAP、ACID 中讨论的一致性称"强一致性",实时一致性,本章讨论的话题“事务”原本的目的就是获得“一致性”，

    弱一致性（Eventual Consistency）：
        而把牺牲了 C 的 AP 系统又要尽可能获得正确的结果的行为称为追求“弱一致性”。
        
        不过，如果单纯只说“弱一致性”那其实就是“不保证一致性”的意思……人类语言这东西真的是博大精深。在弱一致性里，人们又总结出了一种稍微强一点的特例，被称为“最终一致性”（Eventual Consistency），它是指：如果数据在一段时间之内没有被另外的操作所更改，那它最终将会达到与强一致性过程相同的结果，有时候面向最终一致性的算法也被称为“乐观复制算法”。
    

可靠事务队列(采用不断重试的方式):
    1.根据用户扣款，商家收款，库存商品出库三个操作的出错概率评估，根据出错改立大小安排他们的顺序。这种评估一般出现在代码程序中，有一些大型系统会实现动态排序
    2.在系统建立一个消息服务，定时轮训表，将状态是“进行中”的消息同时发送到库存和商家服务节点中，这是可能产生几种情况
        1.商家和仓库服务成功后向账号服务器返回结果。账号服务器把“进行中”改为“已完成”，整个顺利结束，达到最终一致性
        2.商家或仓库服务一个因网络问题，未收到账户消息，此时账户服务一直处于“进行中”，消息服务器在每次轮训的时候持续向未响应的服务重发发送消息，整个步骤决定发送消息服务必须是幂等的，（消费者无响应，重复发送）
        3.商家或仓库服务某个或全部不能工作，譬如发现没有库存，此时，仍然持续自动重发消息，直到操作成功或认为介入。因此，可靠消息队列只要第一步完成了，后续失败回滚的概念，只许成功不需失败。（能响应，业务无法处理，无法改为成功，重复发送）
        4.商家和仓库服务成功后向账号服务器返回结果，但回复的应答消息因网络丢失（生产者无返回响应，重复发送）

        正常
        消费者没收到（重复发送/消费，幂等）
        生产者没收到 （重复发送/消费，幂等）      
        出错/业务无法处理（重复发送/消费，幂等）
                                                

TCC事务
    TCC是另一种常见的分布式事务机制。try-confirm-cancel。
    
    可靠消息队列虽然能保证最终的结果是相对可靠的，过程也足够简单。但整个过程完成没有隔离性可言。有一些业务隔离性无关重要，但有些缺乏隔离性会带来很大麻烦
        如“超售”，完全可能有两个客户在短时间购买一件商品，他们各自购买的数量都不超过，但他们的之和就超过。
    TCC实现上毕竟繁琐，业务侵入式较强的事务方案，要求事务处理过程必须拆分为“预留业务资源”和“确认/释放消费资源”两个过程
        try：尝试阶段，完成所有业务可执行的检查（保障一致性），并预留号全部需要用到的业务资源（保障隔离性）
        confirm：确认阶段，不进行检查，直接用try阶段的资源完成业务处理，confirm阶段可能会重复，所以也需要幂等
        cancel：取消阶段，释放try业务资源，也是需要幂等性

        1.检查业务，生成业务预留资源（n个业务）*这个是重点
        2.循环判断是否全部满足confirm阶段
            confirm处理，如有有一个不满足则抛出cancel
        2.循环判断是否有一个满足cancel阶段
            cancel处理，对try阶段生成的资源进行回收

        1.检查所有逻辑，能处理再进行，不能处理就返回失败
        2.生成业务需要的资源数据(锁库存等)
        3.进行confirm，全部处理完进行返回成功
        4.一个无法处理进行cancel

    TCC是位于代码层的，他的实现带来了较高的灵活性，但是也提高了开发成本及业务侵入性。


SAGA
    TCC事务有较强的隔离性，其性能一般是集中最高的，但不能满足所有的场景，TCC主要是业务侵入性太强。对于第三方无法控制的情况下，TCC第一步的try阶段无法自定义，只能考虑SAGA事务，“长篇故事，长篇叙述，一长串时间”的意思

    与TCC相比，SAGA不需要为资源设计冻结及撤销冻结的操作，补偿操作往往比冻结操作更容易实现。SAGA必须保证子事务都有补偿。
    
    1.把大事务拆成若干的小事务，将整个分布式事务T分解为n个子事务。
    2.为每个子事务都设计对应的补偿动作

    T1,T2,T3 顺序提交，恢复的话
    正向恢复: C1,C2,C3
    反向恢复：C3,C2,C1
