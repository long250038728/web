分布式算法
    如何存放一份数据保持在多个副本数据一致
        1.可靠性，采用多个副本对外进行提供
        2.可用性，需要考虑正确复制的问题

    1.状态转移——主从全量同步：（所有的从节点都更新完才算更新成功），任何一个从节点未响应则会影响到整个事务，每增加一个对应的就可用性风险就多一分
        以牺牲可用性为代价，对于一些关键系统，保证数据正确可靠性同时对可用性要求也非常苛刻。
    2.操作转移——状态机复制：  分布式系统中主流的方式，改变数据的状态，通过某种操作，令源状态转为目标状态，促使产生确定的转移结果的计算模型
        可靠性与可用性的矛盾造成了增加机器反而带来了可用性的减少。
        ***只要确保他们的初始状态一致，并受到的操作指令序列一致即可。所有节点最终的状态是一致的

    分布式环境下网络分区想象不可消除，甚至不再追求系统内的所有节点在任何情况下的状态一致，而是少数服从多数的原则，就可以容忍少数节点失联，从而增加机器数量对整个系统的可用性是有益的。
        协商共识：需要有一种算法能够让分布式系统短暂容忍存在不同的状态，保证大多数节点的状态是一致的。
            共识：指一致性的方法和过程
            一致性：指不同副本之间的差异


Paxos
    提出一种基于消息传递的协商共识算法。是Raft，ZAB算法的先祖。Paxos算法中认为所有节点都是平等的,他们可以承担某一种或多种角色,不过为了便于明确多数派,决策节点应该设置为奇数.且网络中每个节点都知道整个网络所有决策节点的数量、地址等信息。
    
    Paxos算法的目的让城堡内每一位居民都不承诺一定会参与的情况下，按照少数服从多数的原则达到一致意见。（Paxos算法不考虑拜占庭将军问题）
        提案节点：对某个值进行设置操作，这个行为称为提案，值一旦设置成功能够，就不会丢失也不可变。
                Paxos是典型的操作转移模型而非状态转移模型.
                这里的值设置操作,应该理解为日志记录操作
        决策节点：应答提案,会决定是否投票可否被接收,一旦过半决策节点接收,提案批准,
                意味着值不能在被修改,也不能丢失.且最终所有节点都会接收该他
        记录节点：只是单纯的从提案,决策节点中学习已达成的共识提案,比如少数派节点虫网络恢复时,进入会这个状态。


    在分布式环境下，如果我们说各个节点“就是某个值的提案达成一致”，指的是“不存在某个时刻有一个值为A，另一个时刻又为B的情景”。解决这个问题的复杂度主要源于以下两个因素
        现象：
        1.系统内各个通信是不可靠，不论对于系统中企图设置数据的提案节点亦或是决定是否批准设置操作的决策节点。其发出，收到的信息可能延长到达，可能丢失，但不去考虑信息有传递错误的情况（未考虑拜占庭问题）
        2.系统外部各个用户访问是并发的
        实际问题：
        1.分布式系统还需考虑通信故障，如果一个节点取得锁后无释放发送崩溃失联，会导致所有等待阻塞。
        2.在程序设计时对同一变量并发的修改必须先加锁再操作

    Paxos算法分为两个阶段
        1.准备：相当于上面抢占锁的过程，如果提案节点准备发起提案，必须向所有决策节点广播一个申请，提案节点的prepare请求会带全局唯一的提案id，决策节点收到后，将会给予提案节点两个承诺与一个应答
            两个承诺：
                1.不再接受提案id小于等于他的prepare的请求
                2.不再接受提案id小于他的accept请求
            一个应答：（比值比大小，如果值小于我，我就返回我以及处理过的id，如果比我大证明我是通过的）
                不违背承诺的前提下，回复已经批准过的提案id最大的提案所设定的值和提案id，
                    如果值从未被提案过设定过的，返回空值
                如果违背承诺，prepare请求不理会。

        2.应答：当提案节点收到多数决策者的应答，开始第二阶段“批准”过程，有两个可能的结果
            1.如果提案发现所有响应的决策节点都没有批准过该值（空值），说明他是第一个设置值的节点，可以随意决定修改设置的值，将自己选定的值与提案id构成一个二元组（id，value），广播给全部决策节点（称为accept请求）
            2.如果提案节点发现响应的决策节点中，已经有至少一个节点应答中包含有值了，则不能随意取值了，必须无条件的从应答中找出提案最大的那个值进行接受，构成一个二元组（id，maxAcceptValue）,再次广播给所有决策节点称为accept请求）

        流程如下
        1.当每一个决策节点收到accept请求，都会在不违背承诺的前提下，接收并持久化对当前提案id和提案附属的值，
        如果违背承诺，即收到的提案id并不是决策节点决策节点的最大，那允许直接对此accept请求不予理会。
        2.当提案节点收到了多数派决策节点的应答（称为 Accepted 应答）后，协商结束，共识决议形成，将形成的决议发送给所有记录节点进行学习。

Multi Paxos 
    basic Paxos当两个提案“互不相让”的提出自己的提案时会抢占同一个修改的权限，导致整个系统持续“反复横跳”。
    Multi Paxos提出提案节点中实现主次之分，限制每个节点都不受控提案权利，

    流程改变：
    1.提案节点会定期轮序心跳，确定当前网络中的所有节点是否存在一个主提案节点，当发现无主节点存在，节点就会心跳超时后使用basic Paxos定义的准备，批准两轮网络交互，向所有其他节点广播自己希望竞选主节点的请求。如果大多数节点得到批准，则宣告竞选成功。
    2.无论哪个提案节点收到客户端操作请求，都需要转发到主节点来完成提案。
    3.主节点提案则无需再准备过程，可以视为不会有其他节点与他竞争（从并发改为串行）
        
    流程
    1.主节点把更变操作写入自己的变更日志，但先不提交
    2.把更变操作通过心跳包广播给所有的从节点，并要求从节点收到确认回复确认收到的消息，
    3.从节点收到后写入自己的变更日志，给主节点发送确认签收的消息，
    4.主节点收到过半的消息后，提交变更，应答客户端，广播从节点可以提交，
    5.从节点收到后提交，数据在节点间的复制宣告完成


Gossip
    Paxos，Raft,ZAB等分布式算法我们称为“强一致性”，
    Gossip我们称为“最终一致性”，他解决的问题不是像Paxos，Raft等价，只是基于Gossip之上来实现Paxos，Raft的目标。

    流程：
    1.如果有某些信息需要广播所有节点，那么从信息源开始，会选择一个传播周期（如一秒），随机选择与他相连接的k个节点传播
    2.每个节点收到消息后，如果这个消息他之前没接收过，会在下一个周期，选择处理发送消息给他的节点外与其他相邻k个节点发送相同的消息直到所有节点都收到消息，尽管这个过程需要一定时间，但理论上最终所有节点都能接收到这个相同的消息


    Gossip对网络节点的连通性及稳定性几乎没有要求，能够容忍网络节点上的节点随意增加或减少，他们的状态最后会与其他节点进行同步达成一致。没有中间节点或主节点的概念。

    缺点：
    1.需要多次轮播才能全网同步，并不能实时获取最新具有延迟，由于随机选取不可避免会收到重复的情况增加网络压力及带宽。




        


    



