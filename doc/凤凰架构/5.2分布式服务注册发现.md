微服务
    微服务架构一个重要的原则——“通过服务来实现独立的自治组件”
    强调的是“服务”，而不是“类库”，差别在于
        类库是编译期静态链接到程序中，通过调用本地来使用功能
        服务是进程外的组件，通过调用远程方法来使用功能。
    
    1.采用服务来构建程序，收益是软件系统“整体”与“部分”在物理层是完全隔离的，同时代价在于复杂性及执行性能。
    2.每个节点都扮演多重角色（生产者、消费者），形成了复杂的网状调用关系。

    需要有三个问题需要考虑
    1.消费者：外部服务由谁提供（注册发现）
    2.生产者：内部哪些服务要暴露，那些要隐藏，如何暴露，以什么规则在集群中分配请求 （网关路由）
    3.调用过程：如果保证远程服务都能收到相对平均的流量，提高服务的质量及可靠性（负载均衡）

-----------

服务发现
    所有远程服务调用都是使用“全限定名”，“端口号”，“服务标识”来确定一个精准坐标。
        全限定名：网络中某台主机的精确位置。
        端口号:提供了tcp、upd网络的服务程序，标识程序所提供的某个具体方法入口
        服务标识：与具体应用层协议相关（REST服务标识是url，RMI服务标识是Stub,SOAP服务标识是WDSL）
                标识多样性决定了“服务发现”有两种不同的理解，
                    一种以UDDI代表的，上到提供服务的企业信息，下到具体的接口信息
                    另一种是类似DNS（主流）,只满足某个代表服务提供者的全限定名到服务具体的ip地址转换，不关心提供方法，参数等。

 
    发展流程：
        1.初期
            DNS将一个全限定名翻译为一个至多个ip地址或SRV等其他记录便可，
            负载均衡也实质承担一部分服务发现的责职。完成外部ip到内部实际ip的转换。
        2.进阶（随着微服务的发展，服务非正常宕机，重启和正常上下线变得越来越频发，靠着DNS服务器和负载均衡等基础设施已经逐渐不能应对）
            人们最初使用zookeeper这样的分布式k/v框架，通过软件自身来完成服务注册与发现，
        3.进阶2（但Zookeeper是很底层的分布式工具，用户还需要做相当多的工作才能满足需求）
            1.专门用于服务发现的Eureka宣布开源并纳入spring cloud
            2.2018年spring cloud Eureka进入维护模式，consul和nacos很快从Eureka接过传承的衣钵。
    
    服务发现不仅支持DNS或是http请求进行符号与实际地址的装换，还支持健康检查，集中配置，k/v存储，跨数据中心的数据交换等功能，
    扩展功能（负载均衡，流量控制，键值存储，元数据管理，业务分组等）
    分为三个过程
            1.服务注册：
                当服务启动时，通过某种形式发送到注册中心，这过程叫自注册模式(api调用，产生事件消息，在zookeeper/etcd指定位置记录，存入数据库等)
                有容器编排框架或第三方工具注册来完成，如称第三方注册模式（kubernetes和registrator）
            2.服务维护：
                提供下线机制，必须要自己去保证所维护的服务列表是否正确，已避免告知消费者的服务坐标后，得到的服务却不能使用的尴尬，
                支持多种协议（http,tcp等)，多种方式（长连接，心跳，探针，进程状态等）去监控是否健康存活
            3.服务发现：
                把一个符号（serviceid，服务名，或通用FQDN）转换为服务实际坐标过程
                    一般通过http api请求
                    dns loopup操作来完成，
                    或相对少用的方法（kubernetes注入环境来做服务发现）

    CAP
    注册中心的地位是特殊不能完全视为一个普通的服务。因为他不依赖其他服务，但是被其他服务依赖。是最基础的服务。如果注册中心奔溃会导致整个系统不可用，所以一般以集群的方式进行部署来保证高可用。各个注册中心之间可能存在CAP矛盾
        Eureka
            选择保证高可用,牺牲服务状态一致性，采用异步方式复制注册信息，当新服务注册进来时，无需等待其他信息的负载完成，而是马上在该服务发现节点宣布服务可见。有变动或断网、超时，不会实时通知服务器及客户端。常用于不会频繁上下线的系统比较合适，用较小的同步代码换取高可用性。
        Consul
            选择保证高可靠性，采用Raft算法，要求多数派写入成功才能算成功，严格保证服务发现的一致性，同时采用Gossip协议进行同步，他更基于产品实际情况做的技术决策。

    选择
        1.zookeeper，doozerd，etcd（分布式k/v存储框架上自己开发服务发现）
            这类框架宣传语中会主动提及“高可用”，共同特点就是整体较高复杂度的架构和算法的外部，提供极为简单的接口。只有crul及watch等aip，健康检查这些则需要自己实现，
        2.skyDNS,coreDNS以基础设施来实现
            skyDNS从api server中监听集群服务的变化，根据服务生成ns，srv等dns放到etcd中，kubelet会为每个pod设置DNS服务地址为skyDns的地址，需要调用时只需查询DNS转换成ip列表即可实现分布式的服务发现。从kubernetes1.3后，skyDNS不在使用etcd，而是记录在内存中的kubeDNS代替。到了1.11后，更推荐采用扩张性更强的coreDNS,此时可以通过各种插件来决定是否用etcd存储，重定向，定制dns记录，记录日志等
        3.专门用于服务发现的框架和工具Eureka，Consul 和Nacos
            CP的Consul，AP的Eureka 或同时支持CP和AP的Nacos。他们划归为一类由于他们对应用并不透明，以声明式代替编码（spring cloud 中的pom.xml）。这种不透明的会给编码带来一定的便捷，

-----------

网关路由
    1.负载均衡在单体系统承担副本分流流量。
    2.在微服务中网关的存在感就是极大的增强。成为微服务部不可缺少的一部分。
        每个服务节点可能由不同团队负责，都有独立，互不相同的接口，如果服务集群缺少一个统一的入口，
            外部消费之就必须知道所有的微服务及服务在集群中的坐标。为此微服务网关作为统一的出口对外服务，
            将外部访问网关地址的流量，适当的规则路由到内部集群中正确的服务器，（服务网关或api网关）
        网关还提供流量过滤器，安全认证，授权，限流，监控，缓存等功能

    路由功能
        1.网络协议层次
            网关必须能识别流量中的特征，tcp服务那部署四层网关即可，如果以http服务那必须部署七层网关
        2.性能与可用性
            网关的性能将影响全局，系统性。它与自身算法有关。不过因为今天REST和JSON-RPC都基于http对外服务占主流地位，所以需要支持七层路由，通常默认无法直接进行流量转发，只能采取代理模式，性能主要取决于代理网络请求，也就是他的网络I/O模型
        3.网关的可用性（网关视为整个系统入口，网关的地址具有唯一性无法集群部署）
            1.网关尽可能轻量（可以方便做安全，认证，限流，监控，但附加这些功能应该与可用性做权衡，避免增加网关的责职）
            2.应该选择成熟的产品（nginx ingress controller，kong，zull）
            3.应在网关之前部署负载均衡，让更加成熟的设施去充当入口


    网络I/O出入口就是socket的读写，socket在操作系统接口中被抽象为数据流，网络I/O可以理解为对流的操作
        每一次网络访问，从远程主机返回的数据会先存放到操作系统的内核缓冲区中，内核缓存区复制到对应的应用程序的地址空间。
        （所以当发送一次网络请求后，将会顺序经历”等待数据=》远程主机=》缓存区=》应用程序地址空间“）

        人们把网络I/O总结为同步I/O跟异步I/0（阻塞I/O,非阻塞I/O，多路复用I/O，信号驱动I/O）
            1.同步指发送请求后，得到结果前一直等待
                1.阻塞 是请求处理过程中当前线程被挂起（如果还没处理完，就会被阻塞等待，优点在于逻辑清晰，省cpu资源，缺点线程休眠带来上下文切换，需要切换到内核态的重负载操作）

                2.非阻塞 是请求处理过程中当前线程不被挂起（如果还么处理完，就先去处理其他的事，每隔一段时间再过来查询是否处理成功，节省切换上下文，但较长请求会浪费cpu资源）

                3.多路复用 是阻塞I/O的一种，他好处是在同一调阻塞线程上处理多个不同端口的监听（一个线程处理多个监听，一个监听到达则返回）
                    **是最常用的高并发网络（select，epoll，kqueue）
                
                4.信号驱动 他与异步I/O的区别在于”从缓存区获取数据“这个步骤，信号是自己去取，异步是取完告诉你。


            2.异步指发送请求后，立即返回不会马上得到处理结果。结果将通过状态变化和回调通知
                异步I/O数据到达缓冲区后，不需要由调用进程主动进行从缓存区复制数据操作，而是复制完成后由操作系统向线程发送信号

    
    BFF网关
        网关不必为所有前端提供无差别的服务，而是针对不同的前端，聚合不同的业务，提供不同的接口和网络支持，


-----------
负载均衡
    客户端负载均衡
        负载均衡一般部署在整个服务集群的前端，将用户的请求分流到各个服务中处理，但微服务日渐留学，服务集群收到的请求不再是局限于外部，越来越多的请求是集群内部逗哥服务发起，对于这类流量的负载均衡，一种全新独立于每个服务前端，分散式负载均衡正在逐步流行起来
            他与服务端负载均衡的差别在于客户端负载均衡器和服务实例一一对应，与服务实例并存与同一个进程
            优点：
            1.负载均衡与服务之间交换的信息是内部调用，不存在额外的网络开销
            2.不依赖集群边缘的设施，全部内部流量仅在服务集群内部循环，避免集群内要“绕场一周”
            3.避免集中式单点问题
            4.客户端均衡器需要更加灵活（针对不同服务设置不同参数）
            缺点
            1.同个进程意味收到同个编程语言现在
            2.共用进程会影响服务进程的稳定
            3.内部网络安全和信任变得复杂
            4.服务集群拓扑关系是动态的，每一个都需要持续跟踪其他服务的健康，会带来不小负担
        
    代理负载均衡
        服务网格（service mesh）他解决了此前客户端负载均衡的大部分缺陷，他同个进程拆成同一个pod内的特殊服务，不再是进程间的通信，只是服务网格还不够成熟，对操作系统，网络和运维方面的知识也要求较高，但可能将是微服务的主流方式。
            