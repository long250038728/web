## GMP

### 调度器
M 是干活的线程，P 是“执行资格 + 本地队列”，G 是要被执行的 goroutine（M ──绑定──> P ──取 G──> 执行）
* **P**: 调度资源
* **M**: 线程
* **G**: 协程


### 结构
1. 全局队列（由于是全局的队列，在获取时需要加锁操作，所以会比较慢，一般批量获取）
2. M绑定P 
3. P调度资源（有一个runnext优先goroutine，一个本地队列（无锁性能好））


### 使用流程如下
1. P 从`runext`查看是否有优先的goroutine可以处理
2. P 从自己的`本地队列`中获取goroutine进行处理
3. P 从`全局队列`获取goroutine进行处理
4. P 当前处理得过快可以去其他P中获取等待的goroutine（工作窃取避免单一的P调度资源分布不均衡）


### syscall阻塞处理
当syscall时线程阻塞，此时M会与P进行解绑，此时G会放到等待队列中，同时P会去找其他空闲的M进行绑定继续执行其他本地队列的G,当这个G的syscall数据回来后会优先找之前的P，如果P无空闲位置可以放到全局队列中


### goroutine阻塞处理
当goroutine需要等待阻塞处理时会封装为`sudog`结构,放入等待队列中（这个队列是全局的）,此时P会继续处理其他的G，当通道准备接收时唤醒发送方的goroutine,此时会可能放回之前的P中的本地队列或`runnext`或是其他的P。后续切换上下文处理该goroutine
1. select 通道等待
2. time.Sleep
3. 网络等待读写
4. 获取锁

