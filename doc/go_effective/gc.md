# GC概念
识别并回收`堆`上那些`不再被程序使用`的对象（垃圾）


### 常见的垃圾回收机制
* 引用计数器：每个对象都为何一个引用计数，被引用时+1，引用解除时-1，直到0时销毁 （可以很快回收无需等到垃圾回收触发时但是需要实时维护） ———— swift
  * 垃圾回收可以迅速回收，无需等待垃圾回收触发 （单一处理）
* 标记清除：从根遍历所有引用对象，如果没有被标记的视为清除 （无需实时维护但是需要STW时间导致整个不可用）———— go
  * 垃圾回收等待某个节点触发，需要暂停业务扫描清除。（批量处理）
* 分代收集：按照对象的生命周期时长划分不同的代空间，不同代有不同的回收算法和回收频率(性能好可以对不同的代进行配置) ———— java
  * 可以使用不同的回收算法，提高效率


### STW  (go 1.4版本及之前 （该算法是最简单的，但是整个流程业务不可用，可能到秒级别的）)
1. 暂停所有业务逻辑 
2. 开始标记找出能可达/不可达对象 
3. 标记完成清除不可达对象

### 三色标记法 ( go 1.5 Mark与Sweep分离，Sweep可不在STW中)
* 黑色，已经扫描过的对象+子对象为灰色/黑色（子对象一定没有白色）； 
* 灰色，已经扫描过的对象；但所有的子对象还没被扫描完
* 白色，没有扫描的对象

1. 开始：所有对象刚开始都是`白色`
2. 扫描标记：GC开始时(多协程)扫描从root set开始标记， 标记为`灰色`，如果发现子对象指针全部扫描到（灰色）就改为`黑色`
   * 加快GC的方式
     1. `多协程`同时标记跟清除`减少了GC的时间`
     2. 同时标记跟清除允许与应用程序`同时`并行`，不影响正常的业务（应用程序分配内存的速度过快，超出了后台标记的速度，分配内存的goroutine可能会被要求执行标记辅助（Mark Assist），影响系统的正常goroutine）
     3. 在标记过程中如果对数据的删除或插入的时候，需要引入写屏障(直接是灰色)/删除屏障
     4. 为了减少Stop的时间，使用了下面的两个短暂的STW，其他时间都是运行与程序并行处理的
   * 两个STW
     1. 清扫终止（Sweep Termination）阶段 : 发生在新一轮 GC标记开始之前,确保上一轮的清理已经清理结束,初始化下一轮标记所需的内部状态开启写屏障（Write Barrier）
     2. 标记终止 （Mark Termination）阶段 : 最终完成所有标记工作，处理并发期间因写屏障记录的指针变更并确保没有遗漏任何存活对象
3. 清除：扫描全部后剩下的白色节点就是没有已经没被引用（没有灰色的存在即只有黑跟白，白就是需要GC的对象），放到freelist，则可以被清除

### 满足强弱之一，即可保证对象不丢失
* 强三色不变式 ： 强制不允许黑色对象引用白色对象 （让引用他的变为灰色，或新对象为灰色） 
* 弱三色不变式：黑色可以引用白色对象，但需要白色对象存在其他的灰色对象对他引用 (判断引用他的有没有灰色如果有则不变白色，如果没有就需要把新加入的改为灰色)

### 屏障
为了在扫描过程中，允许程序可以不暂停。此时对新增或删除的数据的数据需要对他进行标记处理（白变灰色不垃圾回收）
* 插入写屏障: A对象引用B对象，B对象被标记灰色，如果没有写屏障此时B依旧是白色的就可能被清除 
* 删除写屏障: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色，等到下次GC再处理（弱三色不变式 保护灰色对象到白色对象的路径不会断）

### GC触发
1. GOGC堆大小阈值 GOGC 环境变量或通过debug.SetGCPercent设置（一旦当前已分配的堆内存大小达到上一次 GC 结束后活动堆大小加上由 GOGC 百分比计算出的额外内存量这个目标时）
2. 定时触发（默认两分钟）
3. （go1.19） GOMEMLIMIT(内存限制的触发时机) 环境变量或debug.SetMemoryLimit函数设置一个Go程序内存使用的软上限
4. 手动触发时机 调用 runtime.GC() 可以显式地强制执行一次GC

## 观察和量化这些 GC 开销
1. GODEBUG=gctrace=1 环境变量，可以在运行时获得详细的GC日志等信息
2. 程序内部也可以通过 runtime.ReadMemStats() 函数获取内存和GC的统计数据，分析则可以依赖 runtime/pprof 进行 CPU 和内存剖析，或者使用 go tool trace 进行细粒度的事件追踪

### 如何编写GC友好代码
1. 尽可能少分配`堆`的代码(如使用基本数据类型，减少内存逃逸)--当编译器无法确定一个值的生命周期时（比如动态大小的数据，或者被多处引用可能存活更久），这个值就会逃逸 （escape）到堆（Heap）上
2. 池化复用通过`sync.Pool`
3. 对于字符串拼接少用+= 用string.Builder避免string回收
4. 对于切片跟map尽可能确定size避免扩容
5. GOGC(触发频率 ,默认值100，当新分配的堆内存达到上次 GC 后活动堆大小的 100% 时)  ———— 降低GC的次数，当时会占用更多的内存
6. GOMEMLIMIT （内存使用软上限，限制的是 Go 运行时可使用的总内存量）