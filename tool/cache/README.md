使用缓存或其他中间件，必定有数据不一致的问题
    不一致性只是时间问题————多长的不一致（先更新后删除，延迟双删）

Cache Aside (默认：旁路缓存)
    1.判断是否有缓存
    2.有则返回，无则查数据库（采用singlefight：本地locker的概念）插入缓存（可同步可异步）
    3.返回数据

Cache read through（只管读缓存类）
    到缓存类中读数据，当缓存不存在的时候，内部有方法去获取（依赖注入）

Cache write through（只管写缓存类）
    到缓存类中写数据，内部有方法去写入到其他（依赖注入）

Cache write back（只写缓存）
    所有的东西都是直接操作缓存，等到某个时候写入到其他（依赖注入）————秒杀扣库存




缓存穿透（1.对参数进行判断  2.对无数据的缓存值设置一个默认值）
    数据库也没有该数据，缓存也没缓存空值，导致每次都要去数据库获取同时还要消耗一次redis请求

缓存击穿 （可通过singleflight解决）
    一个热点数据突然过期了，大量的请求直击数据库

缓存雪崩（可对key的过期加一个随机时间，避免大量key同时过期）
    大量的缓存过期，大量的请求直击数据库————缓存预热的场景

解决思路：避免同时大量请求到数据库