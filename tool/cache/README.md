### 缓存一致性
不一致的两个根源
    并发问题（由于缓存只是起到辅助作用，MySQL必定是第一考虑，此时缓存的更新跟删除就要考虑如何配合）
        更新  事务A更新数据库后，事务B也更新了数据库后，事务B比事务A先刷到缓存
        删除  事务A更新数据库后，删除缓存，
            1.读取发现缓存未命中获取数据库更新缓存，此时又有一个事务更新同时删除缓存，此时插入的数据还是之前老数据
            2.此时如果还未删除成功就有读取缓存，此时读到的数据已经是老数据
    部分失败
        更新/删除  事务A更新数据库后，更新/删除缓存失败时，缓存读取的还是老的数据

使用缓存或其他中间件，必定有数据不一致的问题，如无法容忍短期不一致，那就不要用缓存（异构中间件）
    不一致性只是时间问题————多长的不一致（先更新数据库后删除，延迟一定时候在删除————延迟双删）
    
处理方案
    1.把相关的通过负载均衡到同一个服务器上（尽可能是一致性hash），通过采用singlefight处理成一个队列处理（kafka分区的概念）
    2.缓存失败的问题，尽可能设置高可用的缓存中间件，同时通过消息队列延迟删除(增加去数据库读取正确数据的机会)
    


### 缓存类型
Cache Aside (默认：旁路缓存)
    1.判断是否有缓存
    2.有则返回，无则查数据库（采用singlefight：本地locker的概念）插入缓存（可同步可异步）
    3.返回数据

Cache read through（只管读缓存类）
    到缓存类中读数据，当缓存不存在的时候，内部有方法去获取（依赖注入）

Cache write through（只管写缓存类）
    到缓存类中写数据，内部有方法去写入到其他（依赖注入）

Cache write back（只写缓存）
    所有的东西都是直接操作缓存，等到某个时候写入到其他（依赖注入）————秒杀扣库存



### 缓存三个注意事项
缓存穿透（1.对参数进行判断  2.对无数据的缓存值设置一个默认值）
    数据库也没有该数据，缓存也没缓存空值，导致每次都要去数据库获取同时还要消耗一次redis请求

缓存击穿 （可通过singleflight解决）
    一个热点数据突然过期了，大量的请求直击数据库

缓存雪崩（可对key的过期加一个随机时间，避免大量key同时过期）
    大量的缓存过期，大量的请求直击数据库————缓存预热的场景

为什么需要缓存：避免同时大量请求到数据库
解决思路     ：避免同时大量请求到数据库